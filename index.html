<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>2025.09.11現在、機能追加中につき正常に動作しません：特リプTV｜新ハナビ 専用（安定抽出・修正）</title>
<style>
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;margin:24px;color:#111}
  h1{font-size:20px;margin:0 0 12px}
  .hint{background:#fff7ed;border:1px solid #fed7aa;color:#7c2d12;padding:8px 10px;border-radius:8px;font-size:13px}
  .error{background:#fef2f2;border:1px solid #fecaca;color:#991b1b;padding:8px 10px;border-radius:8px;font-size:13px;margin-top:8px;display:none}
  .card{background:#f9fafb;border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin-top:12px}
  .card h3{margin:0 0 8px;font-size:14px}
  textarea{width:100%;height:200px;border:1px solid #e5e7eb;border-radius:8px;padding:8px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:8px}
  @media(min-width:640px){.grid{grid-template-columns:1fr 1fr}}
  label span.key{width:120px;color:#374151;display:inline-block}
  input[type="number"]{border:1px solid #e5e7eb;border-radius:6px;padding:6px 8px;width:100%}
  .perg{font-size:11px;color:#6b7280;width:100px;text-align:right}
  .bar-wrap{width:100%;height:16px;background:#e5e7eb;border-radius:999px;overflow:hidden}
  .bar{height:16px;transition:width .3s ease}
  .rowline{display:flex;align-items:center;justify-content:space-between;font-size:12px;margin-bottom:4px}
  ul.log{margin:6px 0 0 18px;padding:0;font-size:12px;line-height:1.4}
</style>
</head>
<body>
<h1>2025.09.11現在、機能追加中につき正常に動作しません：特リプTV｜新ハナビ 専用（安定抽出・修正）</h1>
<div class="hint">
  貼ったテキストを<strong>行内</strong>→<strong>見出しから末尾までの後方スキャン</strong>の順で解析します。<br>
  総Gは<b>「◯◯G」だけの行</b>を候補にし<b>最大値</b>を採用。OCRの行割れ（例：<code>チェリー⏎合算</code>）は自動結合してから解析します。
</div>

<div id="err" class="error"></div>

<div class="card">
  <div style="display:flex;align-items:center;justify-content:space-between;">
    <h3>テキスト（手動貼り付け）</h3>
    <button id="btn-parse" class="btn" style="background:#2563eb;color:#fff;">テキストから解析</button>
  </div>
  <textarea id="text" placeholder="総プレイ数：6,056G
風鈴合算：813回 1/7.4
チェリー
合算：381回 1/15.9
氷
合算：103回 1/58.8"></textarea>
</div>

<div class="card">
  <h3>抽出メトリクス（編集可）</h3>
  <div class="grid" id="metrics"></div>
  <div id="logbox">
    <h3 style="margin-top:10px">抽出ログ</h3>
    <ul id="log" class="log"></ul>
  </div>
</div>

<div class="card">
  <h3>推測比較（最大=赤、最小=水色／同値は中間色）</h3>
  <div id="bars">必要な数値が揃うと比較グラフが表示されます。</div>
</div>

<script>
/* === 期待値 (/G) — 新ハナビ（通常時 合算） === */
const EXPECT = {
  bell:  [1/7.7,  1/7.6,  1/7.5,  1/7.3],   // 設定: 1,2,5,6 の順
  cherry:[1/16.4, 1/15.3, 1/16.1, 1/15.6],
  ice:   [1/51.2, 1/51.8, 1/48.2, 1/49.3],
};
/* === BB/RT/RBの“分母”期待値（小さいほど出やすい） === */
const EXPECT_DENOM = {
  bb_slant: {1:11.0, 2:9.0, 5:11.0, 6:9.0},        // 斜め風鈴＝偶数優遇
  bb_rare:  {1:16384,2:16384,5:16384,6:655.4},     // バラケ目＝6激強
  rt_hc_miss:{1:6.0,  2:5.8,  5:5.3,  6:5.1},      // HCはずれ
  rt_hg_miss:{1:13.4, 2:12.4, 5:10.1, 6:9.5}       // HGはずれ
};
const WEIGHTS = { bell:1.0, cherry:1.0, ice:0.7, bb_slant:1.1, bb_rare:2.2, rt_hc_miss:1.0, rt_hg_miss:1.0, rb_miss:1.6 };

const state = {
  metrics:{games:undefined,bell:undefined,cherry:undefined,ice:undefined},
  extra:{bb_slant_den:null, bb_rare_den:null, rt_hc_den:null, rt_hg_den:null, rb_miss_count:null},
  log:[]
};

/* ---------- Utils ---------- */
function toNum(x){
  if(x==null) return undefined;
  const n = Number(String(x).replace(/,/g,''));
  return Number.isFinite(n) ? n : undefined;
}
function pushLog(msg){ state.log.push(msg); }
function setError(msg){ const e=document.getElementById("err"); e.style.display=msg?"block":"none"; e.textContent=msg||""; }

function sanitize(s){
  return (s||"")
    .replace(/[０-９]/g, d=>String.fromCharCode(d.charCodeAt(0)-0xFEE0))
    .replace(/[，]/g, ",").replace(/[．]/g, ".")
    .replace(/[：:]\s*/g, ": ")
    .replace(/[　]/g, " ")
    .replace(/[／]/g, "/")
    .replace(/\s+\/\s+/g, "/")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/* ===== 行連結プリプロセス =====
   OCRで見出しが行割れするパターンを1行化する */
function coalesceLines(lines){
  const out=[];
  for(let i=0;i<lines.length;i++){
    let cur=lines[i];

    // 1) 風鈴/チェリー/氷 + 合算
    if(/^(風鈴|チェリー|氷)\s*$/.test(cur) && i+1<lines.length && /^合算\s*$/.test(lines[i+1])){
      out.push(RegExp.$1 + "合算");
      i+=1; continue;
    }
    // 2) 花火チャレンジ中 + はずれ
    if(/^花火チャレンジ中\s*$/.test(cur) && i+1<lines.length && /^(?:はずれ|ハズレ)\s*$/.test(lines[i+1])){
      out.push("花火チャレンジ中はずれ");
      i+=1; continue;
    }
    // 3) 花火GAME中 + はずれ
    if(/^花火GAME中\s*$/.test(cur) && i+1<lines.length && /^(?:はずれ|ハズレ)\s*$/.test(lines[i+1])){
      out.push("花火GAME中はずれ");
      i+=1; continue;
    }
    // 4) レア役（バラケ目）みたいな注釈割れ
    if(/^レア役\s*$/.test(cur) && i+1<lines.length && /[()（].*バラケ目.*[)）]\s*$/.test(lines[i+1])){
      out.push("レア役（バラケ目）");
      i+=1; continue;
    }
    out.push(cur);
  }
  return out;
}

/* パターン（OCRゆらぎに寛容に） */
const RE_G_ONLY      = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*G\s*$/i;
/* 回数の誤読: 回|囘|问|n を許容（語尾の単独 n を “回” 誤読とみなす） */
const RE_KAI_LIKE    = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*(?:回|囘|问|n)\s*$/i;
/* 分母: カンマ入りも許容 → 取り出し後に , を除去して数値化 */
const RE_FRAC_ANY    = /[1Iｌl]\s*\/\s*([0-9][0-9,]*(?:\.[0-9]+)?)/;

/* 行→ {count,denom} 取得 */
function countFrac(line){
  const c = line.match(RE_KAI_LIKE);
  const f = line.match(RE_FRAC_ANY);
  const denom = f ? parseFloat(f[1].replace(/,/g,'')) : undefined;
  return { count: c?toNum(c[1]):undefined, denom };
}

/* 1) “見出しゾーン→値ゾーン”の順次対応（ユニメモの典型） */
function tryZippedMapping(lines){
  const labelStopIdx = (()=> {
    for(let i=0;i<lines.length;i++){
      if(RE_G_ONLY.test(lines[i]) || RE_KAI_LIKE.test(lines[i]) || RE_FRAC_ANY.test(lines[i])) return i;
    }
    return -1;
  })();
  if(labelStopIdx<0 || labelStopIdx<6) return null;

  const labels = lines.slice(0,labelStopIdx).map(s=>s.trim()).filter(Boolean);
  const nums   = [];
  for(let i=labelStopIdx;i<lines.length;i++){
    const {count,denom} = countFrac(lines[i]);
    if(count!=null || denom!=null){
      if(denom==null && i+1<lines.length){
        const f = lines[i+1].match(RE_FRAC_ANY);
        if(f){ nums.push({count, denom:parseFloat(f[1].replace(/,/g,''))}); i++; continue; }
      }
      nums.push({count, denom});
    }
  }
  if(nums.length===0) return null;
  if(Math.abs(labels.length - nums.length) > 10) return null;

  const n = Math.min(labels.length, nums.length);
  const map = {};
  for(let i=0;i<n;i++) map[labels[i]] = nums[i];

  pushLog(`zipped: labels=${n}件, nums=${nums.length}件`);
  return map;
}

/* 2) ラベル検索（フォールバック） */
function findByLabel(mapOrLines, labelRegex){
  if(mapOrLines && !Array.isArray(mapOrLines)){
    for(const k of Object.keys(mapOrLines)){
      if(labelRegex.test(k)) return mapOrLines[k];
    }
    return null;
  }
  const lines = mapOrLines;
  for(let i=0;i<lines.length;i++){
    if(!labelRegex.test(lines[i])) continue;
    const here = countFrac(lines[i]);
    if(here.count!=null || here.denom!=null){
      if(here.denom==null && i+1<lines.length){
        const f = lines[i+1].match(RE_FRAC_ANY);
        if(f) return {count:here.count, denom:parseFloat(f[1].replace(/,/g,''))};
      }
      return here;
    }
    if(i+1<lines.length){
      const c = lines[i+1].match(RE_KAI_LIKE);
      const f = i+2<lines.length ? lines[i+2].match(RE_FRAC_ANY) : null;
      if(c && f) return {count:toNum(c[1]), denom:parseFloat(f[1].replace(/,/g,''))};
    }
  }
  return null;
}

/* === 解析本体 === */
function parseMetricsFromText(raw){
  state.log = [];
  const t = sanitize(raw);
  const rawLines = t.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const lines = coalesceLines(rawLines);    // ★ 行割れを先に結合

  const out = {games:undefined,bell:undefined,cherry:undefined,ice:undefined};
  const extra = {bb_slant_den:null, bb_rare_den:null, rt_hc_den:null, rt_hg_den:null, rb_miss_count:null};

  // 総G：G-only最大を優先
  const cands = lines.map(ln=>{ const m=RE_G_ONLY.exec(ln); return m?toNum(m[1]):null; }).filter(v=>v!=null);
  if(cands.length){ out.games = Math.max(...cands); pushLog(`総G: G-only最大 → ${out.games}`); }
  else pushLog("総G: 見つからず");

  // 見出し↔値の順次マッピング
  const zipped = tryZippedMapping(lines);

  // 通常時 合算
  const bell   = findByLabel(zipped||lines, /風鈴\s*合算/);
  const cherry = findByLabel(zipped||lines, /チェリー\s*合算/);
  const ice    = findByLabel(zipped||lines, /氷\s*合算/);

  if(bell && bell.count!=null)   { out.bell   = bell.count;   pushLog(`風鈴合算: ${out.bell}回（1/${bell.denom??"?"}）`); }
  if(cherry && cherry.count!=null){ out.cherry = cherry.count; pushLog(`チェリー合算: ${out.cherry}回（1/${cherry.denom??"?"}）`); }
  if(ice && ice.count!=null)     { out.ice    = ice.count;    pushLog(`氷合算: ${out.ice}回（1/${ice.denom??"?"}）`); }

  // 追加シグナル：BB/RT/RB
  const bbSlant = findByLabel(zipped||lines, /(風斜め揃い|斜め風鈴|風鈴B|風鈴中段揃)/); // 中段揃いも念のため
  const bbRare  = findByLabel(zipped||lines, /(レア役|バラケ目)/);
  const rtHC    = findByLabel(zipped||lines, /花火チャレンジ中はずれ/);
  const rtHG    = findByLabel(zipped||lines, /花火GAME中はずれ/);
  const rbMiss  = findByLabel(zipped||lines, /(RB中詳細|RB中詳).*?(ハズレ|はずれ)/);

  if(bbSlant && bbSlant.denom!=null){ extra.bb_slant_den = bbSlant.denom; pushLog(`BB斜め風鈴: 1/${extra.bb_slant_den}`); }
  if(bbRare  && bbRare.denom!=null) { extra.bb_rare_den  = bbRare.denom;  pushLog(`BBレア役(=バラケ目): 1/${extra.bb_rare_den}`); }
  if(rtHC    && rtHC.denom!=null)   { extra.rt_hc_den    = rtHC.denom;    pushLog(`HCはずれ: 1/${extra.rt_hc_den}`); }
  if(rtHG    && rtHG.denom!=null)   { extra.rt_hg_den    = rtHG.denom;    pushLog(`HGはずれ: 1/${extra.rt_hg_den}`); }
  if(rbMiss && rbMiss.count!=null)  { extra.rb_miss_count= rbMiss.count;  pushLog(`RB中ハズレ: ${extra.rb_miss_count}回`); }

  state.extra = extra;

  // サマリ
  pushLog(`summary: bell=${out.bell??"-"} | cherry=${out.cherry??"-"} | ice=${out.ice??"-"} | bb_slant=1/${extra.bb_slant_den??"-"} | bb_rare=1/${extra.bb_rare_den??"-"} | hc=1/${extra.rt_hc_den??"-"} | hg=1/${extra.rt_hg_den??"-"} | rb_miss=${extra.rb_miss_count??"-"}`);

  return out;
}

/* ---------- 推測（重み付き誤差→正規化） ---------- */
function estimateAllSettings(m){
  const g = toNum(m.games)||0; if(!g) return [];
  const perG = {};
  ["bell","cherry","ice"].forEach(k=>{
    const v = toNum(m[k]);
    if(Number.isFinite(v)) perG[k]= v/g;
  });

  function errNormal(i){
    let e=0, used=0;
    for(const key of ["bell","cherry","ice"]){
      if(perG[key]!=null){
        e += WEIGHTS[key]*Math.pow(perG[key]-EXPECT[key][i], 2);
        used++;
      }
    }
    return {e, used};
  }
  function errDenom(setting){
    let e=0, used=0;
    if(state.extra.bb_slant_den){
      const exp = EXPECT_DENOM.bb_slant[setting];
      e += WEIGHTS.bb_slant * Math.pow((state.extra.bb_slant_den - exp)/exp, 2); used++;
    }
    if(state.extra.bb_rare_den){
      const exp = EXPECT_DENOM.bb_rare[setting];
      e += WEIGHTS.bb_rare * Math.pow((state.extra.bb_rare_den - exp)/exp, 2); used++;
    }
    if(state.extra.rt_hc_den){
      const exp = EXPECT_DENOM.rt_hc_miss[setting];
      e += WEIGHTS.rt_hc_miss * Math.pow((state.extra.rt_hc_den - exp)/exp, 2); used++;
    }
    if(state.extra.rt_hg_den){
      const exp = EXPECT_DENOM.rt_hg_miss[setting];
      e += WEIGHTS.rt_hg_miss * Math.pow((state.extra.rt_hg_den - exp)/exp, 2); used++;
    }
    if(state.extra.rb_miss_count!=null){
      const miss = state.extra.rb_miss_count;
      if((setting===1 || setting===2) && miss>0){ e += WEIGHTS.rb_miss * (1 + miss); used++; }
      if((setting===5 || setting===6) && miss>0){ e += WEIGHTS.rb_miss * Math.max(0, 1 - miss*0.2) * 0.01; used++; }
    }
    return {e, used};
  }

  const settings=[1,2,5,6];
  const rows = settings.map((s,i)=>{
    const a=errNormal(i), b=errDenom(s);
    const used = a.used + b.used;
    const totalErr = a.e + b.e;
    const score = used? 1/(1+totalErr) : 0;
    return {setting:s, score, percent:0};
  });

  const sum = rows.reduce((x,r)=>x+r.score,0);
  if(sum<=0) return rows.map(r=>({...r,percent:0}));
  return rows.map(r=>({...r,percent:r.score/sum*100}));
}

/* ---------- UI ---------- */
function barColor(p,max,min){
  if(max===min) return "rgba(96,165,250,0.85)";
  if(p===max) return "rgba(239,68,68,0.85)";
  if(p===min) return "rgba(147,197,253,0.85)";
  const t=(p-min)/Math.max(1,(max-min));
  const r=Math.round(147+(59-147)*t), g=Math.round(197+(130-197)*t), b=Math.round(253+(246-253)*t);
  return `rgba(${r},${g},${b},0.9)`;
}

function renderMetrics(){
  const wrap=document.getElementById("metrics"); wrap.innerHTML="";
  const keys=["games","bell","cherry","ice"];
  const label={games:"総G", bell:"風鈴合算", cherry:"チェリー合算", ice:"氷合算"};
  keys.forEach(k=>{
    const row=document.createElement("label"); row.style.display="flex"; row.style.alignItems="center"; row.style.gap="8px";
    const keySpan=document.createElement("span"); keySpan.className="key"; keySpan.textContent=label[k]; row.appendChild(keySpan);
    const input=document.createElement("input"); input.type="number"; input.step="1";
    input.value = (state.metrics[k]??"");
    input.oninput=e=>{
      const v = e.target.value==="" ? undefined : toNum(e.target.value);
      state.metrics[k]=v;
      renderBars(); renderMetrics();
    };
    row.appendChild(input);
    const tail=document.createElement("span"); tail.className="perg";
    if(k!=="games" && toNum(state.metrics.games)){
      const per = (toNum(state.metrics[k])||0)/toNum(state.metrics.games);
      tail.textContent = Number.isFinite(per) ? "/G "+per.toFixed(4) : "";
    }else tail.textContent="";
    row.appendChild(tail);
    wrap.appendChild(row);
  });

  const ul = document.getElementById("log"); ul.innerHTML = "";
  state.log.slice(-20).forEach(msg=>{
    const li=document.createElement("li"); li.textContent=msg; ul.appendChild(li);
  });
}

function renderBars(){
  const mount=document.getElementById("bars");
  const rows=estimateAllSettings(state.metrics);
  if(!rows.length){ mount.textContent="必要な数値が揃うと比較グラフが表示されます。"; return; }
  const perc=rows.map(r=>r.percent), max=Math.max(...perc), min=Math.min(...perc);
  mount.innerHTML="";
  rows.forEach(r=>{
    const head=document.createElement("div"); head.className="rowline";
    head.innerHTML=`<span>新ハナビ｜設定${r.setting}</span><span>${r.percent.toFixed(2)}%</span>`;
    const barWrap=document.createElement("div"); barWrap.className="bar-wrap";
    const bar=document.createElement("div"); bar.className="bar";
    const width = Math.max(0, Math.min(100, isFinite(r.percent)? r.percent : 0));
    bar.style.width = width + "%";
    bar.style.background = barColor(r.percent,max,min);
    barWrap.appendChild(bar);
    mount.appendChild(head); mount.appendChild(barWrap);
  });
}

/* ---------- init ---------- */
function init(){
  try{
    renderMetrics(); renderBars();
    document.getElementById("btn-parse").addEventListener("click", ()=>{
      try{
        setError("");
        const text=document.getElementById("text").value||"";
        state.metrics = parseMetricsFromText(text);

        if(!toNum(state.metrics.games)){
          setError("総G（例: 6,056G）が見つかりませんでした。");
        }else{
          const got=["bell","cherry","ice"].filter(k=>toNum(state.metrics[k])!=null);
          if(got.length===0) setError("『風鈴合算／チェリー合算／氷合算』が見つかりませんでした。");
        }
        renderMetrics(); renderBars();
      }catch(err){ setError("解析中にエラー: "+(err&&err.message?err.message:String(err))); }
    });

    // 自己テスト（行割れ＋カンマ入り分母＋回→n誤読混合）
    const sample = `新ハナビ
基本情報
総プレイ数
小役
風鈴
合算
氷
合算
チェリー
合算
BB中詳細
風斜め揃い
レア役
RT
花火チャレンジ中
はずれ
花火GAME中
はずれ
6,056G
813回
1/7.4
103回
1/58.8
381n
1/15.9
103回
1/9.8
1回
1/655.4
83回
1/6.1
42回
1/13.0
1/1,014.0`;
    const m=parseMetricsFromText(sample);
    console.assert(m.games===6056 && m.bell===813 && m.ice===103 && m.cherry===381, "parse 合算OK");
  }catch(err){ setError("初期化エラー: "+(err&&err.message?err.message:String(err))); }
}
init();
</script>
</body>
</html>
