<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>特リプTV｜新ハナビ 専用（テキスト解析・安定版）</title>
<style>
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;margin:24px;color:#111}
  h1{font-size:20px;margin:0 0 12px}
  .hint{background:#fff7ed;border:1px solid #fed7aa;color:#7c2d12;padding:8px 10px;border-radius:8px;font-size:13px}
  .error{background:#fef2f2;border:1px solid #fecaca;color:#991b1b;padding:8px 10px;border-radius:8px;font-size:13px;margin-top:8px;display:none}
  .row{display:flex;flex-wrap:wrap;align-items:center;gap:8px;margin-top:12px}
  .btn{font-size:13px;padding:6px 10px;border-radius:6px;border:0;cursor:pointer}
  .btn.primary{background:#111;color:#fff}
  .card{background:#f9fafb;border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin-top:12px}
  .card h3{margin:0 0 8px;font-size:14px}
  textarea{width:100%;height:160px;border:1px solid:#e5e7eb;border-radius:8px;padding:8px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:8px}
  @media(min-width:640px){.grid{grid-template-columns:1fr 1fr}}
  label span.key{width:120px;color:#374151;display:inline-block}
  input[type="number"]{border:1px solid #e5e7eb;border-radius:6px;padding:6px 8px;width:100%}
  .perg{font-size:11px;color:#6b7280;width:80px;text-align:right}
  .bar-wrap{width:100%;height:16px;background:#e5e7eb;border-radius:999px;overflow:hidden}
  .bar{height:16px;transition:width .3s ease}
  .rowline{display:flex;align-items:center;justify-content:space-between;font-size:12px;margin-bottom:4px}
  .footer{margin-top:16px;font-size:12px;color:#6b7280}
  code{background:#f3f4f6;padding:0 4px;border-radius:4px}
</style>
</head>
<body>
<h1>特リプTV｜新ハナビ 専用（テキスト解析・安定版）</h1>
<div class="hint">
  ユニメモのテキストをそのまま貼って「テキストから解析」。<br>
  ※ 総Gは <b>「6,056G」形式の行</b>のみ採用。小役は<b>「◯回」＋直後の「1/◯◯」</b>のペアで役判定します。
</div>

<div id="err" class="error"></div>

<div class="card">
  <div style="display:flex;align-items:center;justify-content:space-between;">
    <h3>テキスト（手動貼り付け）</h3>
    <button id="btn-parse" class="btn primary" type="button">テキストから解析</button>
  </div>
  <textarea id="text" placeholder="（ここにユニメモのテキストを丸ごと貼り付け）"></textarea>
</div>

<div class="card">
  <h3>抽出メトリクス（編集可）</h3>
  <div class="grid" id="metrics"></div>
</div>

<div class="card">
  <h3>推測比較（最大=赤、最小=水色）</h3>
  <div id="bars">必要な数値が揃うと比較グラフが表示されます。</div>
</div>

<div class="footer">
  元のUI/算出の流れを維持しつつ、ユニメモの新UI（設定推測ボタン等）で生じた表記ノイズを無視するようにしました。:contentReference[oaicite:1]{index=1}
</div>

<script>
/* === 期待値 (/G) === */
const EXPECT = {
  bell:  [1/7.7,  1/7.6,  1/7.5,  1/7.3],
  cherry:[1/16.4, 1/15.3, 1/16.1, 1/15.6],
  ice:   [1/51.2, 1/51.8, 1/48.2, 1/49.3],
};

const state = { metrics: { games: undefined, bell: undefined, cherry: undefined, ice: undefined } };

/* ---- 正規化 ---- */
function sanitize(s){
  return (s||"")
    .replace(/[０-９]/g,d=>String.fromCharCode(d.charCodeAt(0)-0xFEE0))
    .replace(/[，]/g,",").replace(/[．]/g,".").replace(/[　]/g," ")
    .replace(/[：:]\s*/g,":")
    .replace(/\s+\/\s+/g,"/")
    .replace(/\s{2,}/g," ")
    .trim();
}

/* ---- パターン ---- */
const RE_LINE_G_ONLY   = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*G\s*$/i;     // 行全体が「◯◯G」
const RE_LINE_KAI_ONLY = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*回\s*$/;      // 行全体が「◯◯回」
const RE_LINE_FRAC     = /^\s*1\s*\/\s*([0-9]+(?:\.[0-9]+)?)\s*$/;       // 行全体が「1/◯◯」
const RE_INLINE_GAMES  = /総[ププ]レイ|総プレイ数|総ゲーム|総回転|総G数|ゲーム数|回転数/i;

/* ---- 役の判定レンジ（分母のレンジで推定） ---- */
const RANGES = {
  bell:   [6,  9],   // 1/6〜1/9 くらい
  cherry: [13, 18],  // 1/13〜1/18
  ice:    [45, 80],  // 1/45〜1/80
};
function roleByDenom(d){
  if(d>=RANGES.bell[0]   && d<=RANGES.bell[1])   return "bell";
  if(d>=RANGES.cherry[0] && d<=RANGES.cherry[1]) return "cherry";
  if(d>=RANGES.ice[0]    && d<=RANGES.ice[1])    return "ice";
  return null;
}

/* ---- 抽出本体（新ハナビ専用） ---- */
function parseMetricsFromText(textRaw){
  const t = sanitize(textRaw);
  const lines = t.split(/\r?\n/);

  const out = { games: undefined, bell: undefined, cherry: undefined, ice: undefined };

  // 1) 総G：行全体が「◯◯G」の候補のみ集め、最大値を採用（100G以内…等は自然に除外）
  const gCandidates = lines
    .map((ln)=>{ const m=RE_LINE_G_ONLY.exec(ln); return m? Number(m[1].replace(/,/g,"")):null; })
    .filter(v=>v!=null);
  if(gCandidates.length){
    out.games = Math.max(...gCandidates);
  }else{
    // フォールバック：見出し行の「後方」に出るG-only行を拾う
    const idxHead = lines.findIndex(ln=>RE_INLINE_GAMES.test(ln));
    if(idxHead>=0){
      for(let i=idxHead+1;i<lines.length;i++){
        const m=RE_LINE_G_ONLY.exec(lines[i]); if(m){ out.games = Number(m[1].replace(/,/g,"")); break; }
      }
    }
  }

  // 2) 小役： 「◯回」行 + 直後の「1/◯◯」行 のペアをすべて拾い、分母レンジで役に振り分け
  //   ※ 同じ役が複数出たら「回数が大きい方」を採用（A/B等の内訳が先に来てもOK）
  for(let i=0;i<lines.length-1;i++){
    const mCnt = RE_LINE_KAI_ONLY.exec(lines[i]);
    const mFrac= RE_LINE_FRAC.exec(lines[i+1]);
    if(!mCnt || !mFrac) continue;
    const count = Number(mCnt[1].replace(/,/g,""));
    const denom = parseFloat(mFrac[1]);
    const role  = roleByDenom(denom);
    if(!role) continue;
    if(out[role]==null || count > out[role]) out[role] = count;
  }

  return out;
}

/* ---- 推測（元の算出と同じ：二乗誤差→正規化） ---- */
function estimateAllSettings(metrics){
  const g = metrics.games || 0;
  if(!g) return [];
  const perG = {};
  ["bell","cherry","ice"].forEach(k=>{ if(metrics[k]!=null) perG[k]=metrics[k]/g; });

  const rows=[1,2,5,6].map((s,i)=>{
    let err=0, used=0;
    if(perG.bell  !=null){ err += Math.pow(perG.bell  - EXPECT.bell[i] ,2); used++; }
    if(perG.cherry!=null){ err += Math.pow(perG.cherry- EXPECT.cherry[i],2); used++; }
    if(perG.ice   !=null){ err += Math.pow(perG.ice   - EXPECT.ice[i]   ,2); used++; }
    const score = used ? 1/(1+err) : 0;
    return { setting:s, score, percent:0 };
  });
  const sum = rows.reduce((a,b)=>a+b.score,0) || 1;
  rows.forEach(r=>r.percent = r.score/sum*100);
  return rows;
}

/* ---- UI ---- */
function barColor(p,max,min){
  if(p===max) return"rgba(239,68,68,0.85)";
  if(p===min) return"rgba(147,197,253,0.85)";
  const t=(p-min)/Math.max(1,max-min);
  const r=Math.round(147+(59-147)*t), g=Math.round(197+(130-197)*t), b=Math.round(253+(246-253)*t);
  return`rgba(${r},${g},${b},0.9)`;
}
function renderMetrics(){
  const wrap=document.getElementById("metrics"); wrap.innerHTML="";
  const keys=["games","bell","cherry","ice"];
  const label={games:"総G", bell:"風鈴合算", cherry:"チェリー合算", ice:"氷合算"};
  keys.forEach(k=>{
    const row=document.createElement("label"); row.style.display="flex"; row.style.alignItems="center"; row.style.gap="8px";
    const keySpan=document.createElement("span"); keySpan.className="key"; keySpan.textContent=label[k]; row.appendChild(keySpan);
    const input=document.createElement("input"); input.type="number"; input.inputMode="numeric";
    input.value = state.metrics[k] ?? "";
    input.oninput = (e)=>{ state.metrics[k] = e.target.value==="" ? undefined : Number(e.target.value); renderBars(); renderMetrics(); };
    row.appendChild(input);
    const tail=document.createElement("span"); tail.className="perg";
    if(k!=="games" && state.metrics.games){ tail.textContent="/G "+(((state.metrics[k]||0)/(state.metrics.games||1)).toFixed(4)); }
    row.appendChild(tail);
    wrap.appendChild(row);
  });
}
function renderBars(){
  const mount=document.getElementById("bars");
  const rows=estimateAllSettings(state.metrics);
  if(!rows.length){ mount.textContent="必要な数値が揃うと比較グラフが表示されます。"; return; }
  const perc=rows.map(r=>r.percent), max=Math.max(...perc), min=Math.min(...perc);
  mount.innerHTML="";
  rows.forEach(r=>{
    const head=document.createElement("div"); head.className="rowline";
    head.innerHTML=`<span>新ハナビ｜設定${r.setting}</span><span>${r.percent.toFixed(2)}%</span>`;
    const barWrap=document.createElement("div"); barWrap.className="bar-wrap";
    const bar=document.createElement("div"); bar.className="bar";
    bar.style.width=Math.max(0,Math.min(100,r.percent))+"%";
    bar.style.background=barColor(r.percent,max,min);
    barWrap.appendChild(bar);
    mount.appendChild(head); mount.appendChild(barWrap);
  });
}

/* ---- init ---- */
function setError(msg){ const e=document.getElementById("err"); e.style.display=msg?"block":"none"; e.textContent=msg||""; }
function init(){
  renderMetrics(); renderBars();
  document.getElementById("btn-parse").addEventListener("click", ()=>{
    setError("");
    const text=document.getElementById("text").value||"";
    state.metrics = parseMetricsFromText(text);

    // 簡易バリデーション
    if(!state.metrics.games){ setError("総G（例: 6,056G）が見つかりませんでした。"); }
    else{
      const got = ["bell","cherry","ice"].filter(k=>state.metrics[k]!=null);
      if(got.length===0) setError("小役回数（◯回）＋直後の 1/◯◯ が見つかりませんでした。");
    }
    renderMetrics(); renderBars();
  });

  // 自己テスト（今回いただいた例に近い値）
  try{
    const sample = [
      "総プレイ数","小役","風鈴合算","氷合算","チェリー合算",
      "6,056G",
      "813回","1/7.4",
      "103回","1/58.8",
      "381回","1/15.9",
      "100G以内最大連チャン","4",
    ].join("\n");
    const m = parseMetricsFromText(sample);
    console.assert(m.games===6056 && m.bell===813 && m.cherry===381 && m.ice===103, "pair parsing ok");
  }catch(_){}
}
init();
</script>
</body>
</html>
