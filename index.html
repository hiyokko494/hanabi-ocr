<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>特リプTV｜新ハナビ 専用（テキスト解析）</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", "Meiryo", sans-serif; margin: 24px; color: #111; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .hint { background:#fff7ed; border:1px solid #fed7aa; color:#7c2d12; padding:8px 10px; border-radius:8px; font-size:13px; }
    .error { background:#fef2f2; border:1px solid #fecaca; color:#991b1b; padding:8px 10px; border-radius:8px; font-size:13px; margin-top:8px; display:none; }
    .row { display:flex; flex-wrap:wrap; align-items:center; gap:8px; margin-top:12px; }
    .btn { font-size:13px; padding:6px 10px; border-radius:6px; border:0; cursor:pointer; }
    .btn.primary { background:#111; color:#fff; }
    .card { background:#f9fafb; border:1px solid #e5e7eb; border-radius:10px; padding:12px; margin-top:12px; }
    .card h3 { margin:0 0 8px; font-size:14px; }
    textarea { width:100%; height:140px; border:1px solid #e5e7eb; border-radius:8px; padding:8px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size:12px; }
    .grid { display:grid; grid-template-columns:1fr; gap:8px; }
    @media (min-width:640px){ .grid{ grid-template-columns:1fr 1fr; } }
    label span.key { width:120px; color:#374151; display:inline-block; }
    input[type="number"] { border:1px solid #e5e7eb; border-radius:6px; padding:6px 8px; width:100%; }
    .perg { font-size:11px; color:#6b7280; width:80px; text-align:right; }
    .bar-wrap { width:100%; height:16px; background:#e5e7eb; border-radius:999px; overflow:hidden; }
    .bar { height:16px; transition: width 300ms ease; }
    .rowline { display:flex; align-items:center; justify-content:space-between; font-size:12px; margin-bottom:4px; }
    .footer { margin-top:16px; font-size:12px; color:#6b7280; }
    code { background:#f3f4f6; padding:0 4px; border-radius:4px; }
  </style>
</head>
<body>
  <h1>特リプTV｜新ハナビ 専用（テキスト解析）</h1>
  <div class="hint">
    1) ユニメモの遊技履歴画像を「画像にする」→iPhone等でテキスト全選択→コピー<br>
    2) 下のテキスト欄にそのまま貼り付け→<b>テキストから解析</b><br>
    ※ 見出しと数値が離れて並ぶ形式でも動きます（例：先に「風鈴合算」等の見出し行、後ろに「813回」等の数値行）。
  </div>

  <div id="err" class="error"></div>

  <div class="card">
    <div style="display:flex; align-items:center; justify-content:space-between;">
      <h3>テキスト（手動貼り付け）</h3>
      <button id="btn-parse" class="btn primary" type="button">テキストから解析</button>
    </div>
    <textarea id="text" placeholder="例)
新ハナビ
基本情報
総プレイ数
小役
風鈴合算
氷合算
チェリー合算
……
6,056G
813回 1/7.4
103回 1/58.8
381回 1/15.9
"></textarea>
  </div>

  <div class="card">
    <h3>抽出メトリクス（編集可）</h3>
    <div class="grid" id="metrics"></div>
  </div>

  <div class="card">
    <h3>推測比較（最大=赤、最小=水色）</h3>
    <div id="bars">必要な数値が揃うと比較グラフが表示されます。</div>
  </div>

  <div class="footer">
    元indexの挙動をベースに、一致行が無い時だけ見出し→後方の「◯回/◯G」を対応付けます。:contentReference[oaicite:1]{index=1}
  </div>

<script>
/** 期待値 (/G) — 元indexの値に準拠 */
const EXPECT = {
  bell:  [1/7.7,  1/7.6,  1/7.5,  1/7.3],
  cherry:[1/16.4, 1/15.3, 1/16.1, 1/15.6],
  ice:   [1/51.2, 1/51.8, 1/48.2, 1/49.3],
};

const state = { metrics: { games: undefined, bell: undefined, cherry: undefined, ice: undefined } };

/* --- 正規化 --- */
function sanitize(s){
  return (s||"")
    .replace(/[０-９]/g, d=>String.fromCharCode(d.charCodeAt(0)-0xFEE0))
    .replace(/[，]/g,",").replace(/[．]/g,".").replace(/[　]/g," ")
    .replace(/[：:]\s*/g,":")
    .replace(/\s+\/\s+/g,"/")
    .replace(/\s{2,}/g," ")
    .trim();
}

/* --- 共通パターン --- */
const RE_G   = /([0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)\s*G\b/i;
const RE_KAI = /([0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)\s*回\b/;
const RE_FRAC= /(^|[^0-9])1\s*\/\s*[0-9.]/;

/* --- 1. 元indexの“同一行抽出”をまず実行 --- */
function parseInline(lines){
  const findLine = (re)=> lines.find(l=>re.test(l));
  const getNum   = (line, wantG)=> {
    if(!line) return undefined;
    if(RE_FRAC.test(line)) return undefined; // 1/◯◯ は無視
    const m = (wantG?RE_G:RE_KAI).exec(line);
    return m ? Number(m[1].replace(/,/g,"")) : undefined;
  };
  const gamesLine  = findLine(/総[ププ]レイ|総プレイ数|総ゲーム|ゲーム数|回転数/i);
  const bellLine   = findLine(/風鈴\s*合算|風鈴合算/i);
  const cherryLine = findLine(/チェリー\s*合算|チェリー合算/i);
  const iceLine    = findLine(/氷\s*合算|氷合算/i);

  return {
    games:  getNum(gamesLine, true),
    bell:   getNum(bellLine, false),
    cherry: getNum(cherryLine, false),
    ice:    getNum(iceLine, false),
  };
}

/* --- 2. 同一行で拾えない場合だけ“見出し→後続カウント割当” --- */
function parseByMapping(lines){
  // 見出し位置
  const head = {
    games:  lines.findIndex(l=>/総[ププ]レイ|総プレイ数|総ゲーム|ゲーム数|回転数/i.test(l)),
    bell:   lines.findIndex(l=>/風鈴\s*合算|風鈴合算/i.test(l)),
    cherry: lines.findIndex(l=>/チェリー\s*合算|チェリー合算/i.test(l)),
    ice:    lines.findIndex(l=>/氷\s*合算|氷合算/i.test(l)),
  };
  // 後続に出てくる「◯G」「◯回」を列挙（分数は除外）
  const counts = lines.map((ln,idx)=>{
    if(RE_FRAC.test(ln)) return null;
    const g = RE_G.exec(ln);
    const k = RE_KAI.exec(ln);
    return g ? {idx, type:"G",   val:Number(g[1].replace(/,/g,""))}
         : k ? {idx, type:"KAI", val:Number(k[1].replace(/,/g,""))}
         : null;
  }).filter(Boolean);

  const takeAfter = (pos, type)=>{
    const found = counts.find(c=>c.idx>pos && c.type===type);
    if(!found) return undefined;
    // 使い回し防止
    counts.splice(counts.indexOf(found),1);
    return found.val;
  };

  return {
    games:  head.games  >=0 ? takeAfter(head.games,  "G")   : undefined,
    bell:   head.bell   >=0 ? takeAfter(head.bell,   "KAI") : undefined,
    cherry: head.cherry >=0 ? takeAfter(head.cherry, "KAI") : undefined,
    ice:    head.ice    >=0 ? takeAfter(head.ice,    "KAI") : undefined,
  };
}

function parseMetricsFromText(text){
  const t = sanitize(text);
  const lines = t.split(/\r?\n/);

  // まず元仕様（同一行）でトライ
  let m = parseInline(lines);

  // games か 小役が欠けていれば、見出し→後続マッピングで補完
  if(!m.games || m.bell==null || m.cherry==null || m.ice==null){
    const fill = parseByMapping(lines);
    m = {
      games:  m.games  || fill.games,
      bell:   m.bell   ?? fill.bell,
      cherry: m.cherry ?? fill.cherry,
      ice:    m.ice    ?? fill.ice,
    };
  }
  return m;
}

/* --- 推測（一致しない項目は“使わない”） --- */
function estimateAllSettings(metrics){
  const g = metrics.games || 0;
  if(!g) return [];
  const perG = {};
  ["bell","cherry","ice"].forEach(k=>{
    if(metrics[k]!=null) perG[k] = metrics[k]/g;
  });

  const base = [1,2,5,6];
  const rows = base.map((s,i)=>{
    let err=0, used=0;
    if(perG.bell  !=null){ err += Math.pow(perG.bell  - EXPECT.bell[i] ,2); used++; }
    if(perG.cherry!=null){ err += Math.pow(perG.cherry- EXPECT.cherry[i],2); used++; }
    if(perG.ice   !=null){ err += Math.pow(perG.ice   - EXPECT.ice[i]   ,2); used++; }
    const score = used ? 1/(1+err) : 0;
    return { setting:s, score, percent:0 };
  });
  const sum = rows.reduce((a,b)=>a+b.score,0) || 1;
  rows.forEach(r=>r.percent = r.score/sum*100);
  return rows;
}

/* --- UI --- */
function barColor(p,max,min){
  if(p===max) return"rgba(239,68,68,0.85)";
  if(p===min) return"rgba(147,197,253,0.85)";
  const t=(p-min)/Math.max(1,max-min);
  const r=Math.round(147+(59-147)*t), g=Math.round(197+(130-197)*t), b=Math.round(253+(246-253)*t);
  return`rgba(${r},${g},${b},0.9)`;
}

function renderMetrics(){
  const wrap=document.getElementById("metrics"); wrap.innerHTML="";
  const keys=["games","bell","cherry","ice"];
  const label={games:"総G", bell:"風鈴合算", cherry:"チェリー合算", ice:"氷合算"};
  keys.forEach(k=>{
    const row=document.createElement("label"); row.style.display="flex"; row.style.alignItems="center"; row.style.gap="8px";
    const keySpan=document.createElement("span"); keySpan.className="key"; keySpan.textContent=label[k]; row.appendChild(keySpan);
    const input=document.createElement("input"); input.type="number"; input.inputMode="numeric";
    input.value = state.metrics[k] ?? "";
    input.oninput = (e)=>{ state.metrics[k] = e.target.value==="" ? undefined : Number(e.target.value); renderBars(); renderMetrics(); };
    row.appendChild(input);
    const tail=document.createElement("span"); tail.className="perg";
    if(k!=="games" && state.metrics.games){ tail.textContent="/G "+(((state.metrics[k]||0)/(state.metrics.games||1)).toFixed(4)); }
    row.appendChild(tail);
    wrap.appendChild(row);
  });
}

function renderBars(){
  const mount=document.getElementById("bars");
  const rows=estimateAllSettings(state.metrics);
  if(!rows.length){ mount.textContent="必要な数値が揃うと比較グラフが表示されます。"; return; }
  const perc=rows.map(r=>r.percent), max=Math.max(...perc), min=Math.min(...perc);
  mount.innerHTML="";
  rows.forEach(r=>{
    const head=document.createElement("div"); head.className="rowline";
    head.innerHTML=`<span>新ハナビ｜設定${r.setting}</span><span>${r.percent.toFixed(2)}%</span>`;
    const barWrap=document.createElement("div"); barWrap.className="bar-wrap";
    const bar=document.createElement("div"); bar.className="bar";
    bar.style.width=Math.max(0,Math.min(100,r.percent))+"%";
    bar.style.background=barColor(r.percent,max,min);
    barWrap.appendChild(bar);
    mount.appendChild(head); mount.appendChild(barWrap);
  });
}

function setError(msg){ const box=document.getElementById("err"); box.style.display=msg?"block":"none"; box.textContent=msg||""; }

/* --- init --- */
function init(){
  renderMetrics(); renderBars();
  document.getElementById("btn-parse").addEventListener("click", ()=>{
    setError("");
    const text=document.getElementById("text").value||"";
    state.metrics = parseMetricsFromText(text);
    const got = Object.values(state.metrics).filter(v=>v!=null).length;
    if(!state.metrics.games) setError("総プレイ数（◯◯G）が見つかりません。テキスト内に『◯◯G』の行を含めてください。");
    else if(got<=1) setError("小役回数（◯◯回）が見つかりません。『風鈴合算／チェリー合算／氷合算』の見出しと、後ろの回数行を含めてペーストしてください。");
    renderMetrics(); renderBars();
  });

  // 動作自己テスト（元index想定の1行内表記）
  try{
    const sample = "総プレイ数 6,056G\n風鈴合算 813回 1/7.4\nチェリー合算 381回 1/15.9\n氷合算 103回 1/58.8";
    const m = parseMetricsFromText(sample);
    console.assert(m.games===6056 && m.bell===813 && m.cherry===381 && m.ice===103, "inline parse ok");
  }catch(_){}
}

init();
</script>
</body>
</html>
