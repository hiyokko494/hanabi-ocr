<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>05 2025.09.11現在、機能追加中につき正常に動作しません：特リプTV｜新ハナビ 専用（安定抽出・修正）</title>
<style>
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;margin:24px;color:#111}
  h1{font-size:20px;margin:0 0 12px}
  .hint{background:#fff7ed;border:1px solid #fed7aa;color:#7c2d12;padding:8px 10px;border-radius:8px;font-size:13px}
  .error{background:#fef2f2;border:1px solid #fecaca;color:#991b1b;padding:8px 10px;border-radius:8px;font-size:13px;margin-top:8px;display:none}
  .card{background:#f9fafb;border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin-top:12px}
  .card h3{margin:0 0 8px;font-size:14px}
  textarea{width:100%;height:200px;border:1px solid #e5e7eb;border-radius:8px;padding:8px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:8px}
  @media(min-width:720px){.grid{grid-template-columns:1fr 1fr}}
  label span.key{width:150px;color:#374151;display:inline-block}
  input[type="number"]{border:1px solid #e5e7eb;border-radius:6px;padding:6px 8px;width:100%}
  .perg{font-size:11px;color:#6b7280;width:100px;text-align:right}
  .bar-wrap{width:100%;height:16px;background:#e5e7eb;border-radius:999px;overflow:hidden}
  .bar{height:16px;transition:width .3s ease}
  .rowline{display:flex;align-items:center;justify-content:space-between;font-size:12px;margin-bottom:4px}
  ul.log{margin:6px 0 0 18px;padding:0;font-size:12px;line-height:1.4}
  .opts{display:flex;gap:14px;align-items:center;font-size:13px;color:#374151;margin-top:8px}
  .muted{color:#6b7280}
  .kv{display:flex;align-items:center;gap:8px}
  .secnote{font-size:12px;color:#6b7280;margin-top:4px}
  .pill{display:inline-block;background:#eef2ff;color:#3730a3;border-radius:999px;padding:2px 8px;font-size:11px}
  .two-col{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:900px){.two-col{grid-template-columns:1fr 1fr}}
  .subgrid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
</style>
</head>
<body>
<h1>05 2025.09.11現在、機能追加中につき正常に動作しません：特リプTV｜新ハナビ 専用（安定抽出・修正）</h1>
<div class="hint">
  OCR崩れに強い抽出（<b>行連結</b>→<b>近傍±8行×分母レンジ</b>→全体フォールバック）＋<b>二項ログ尤度</b>で設定比較。<br>
  REG後の<b>ピースマーク</b>ONで「設定1＝0%」にします。
</div>

<div id="err" class="error"></div>

<div class="card">
  <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
    <h3>テキスト（手動貼り付け）</h3>
    <div class="opts">
      <label class="kv"><input id="edit-mode" type="checkbox"> 編集モード</label>
      <label class="kv"><input id="peace" type="checkbox"> ピースマーク出現（設定2以上確定）</label>
      <button id="btn-parse" class="btn" style="background:#2563eb;color:#fff;border:none;border-radius:8px;padding:6px 10px;">テキストから解析</button>
    </div>
  </div>
  <textarea id="text" placeholder="総プレイ数：6,056G
風鈴合算：813回 1/7.4
チェリー合算：393回 1/15.4
氷合算：103回 1/58.8"></textarea>
  <div class="secnote">※OCRで <code>チェリー⏎合算</code> / <code>花火チャレンジ中⏎はずれ</code> などの行割れは自動結合します。</div>
</div>

<div class="two-col">
  <div class="card">
    <h3>抽出メトリクス（編集可 / 編集モードOFFで固定）</h3>
    <div class="grid" id="metrics"></div>
  </div>

  <div class="card">
    <h3>抽出シグナル（読み取り専用）</h3>
    <div class="subgrid">
      <div><span class="key">BB斜め風鈴</span><span id="sig-bb-slant" class="pill muted">—</span></div>
      <div><span class="key">BBレア役(バラケ目)</span><span id="sig-bb-rare" class="pill muted">—</span></div>
      <div><span class="key">HCはずれ</span><span id="sig-rt-hc" class="pill muted">—</span></div>
      <div><span class="key">HGはずれ</span><span id="sig-rt-hg" class="pill muted">—</span></div>
      <div><span class="key">RB中ハズレ（回）</span><span id="sig-rb-miss" class="pill muted">—</span></div>
    </div>
    <div class="secnote">※数値が抽出できなかったシグナルは「—」表示。</div>
  </div>
</div>

<div class="card">
  <h3>推測比較（最大=赤、最小=水色／同値は中間色）</h3>
  <div id="bars">必要な数値が揃うと比較グラフが表示されます。</div>
</div>

<div class="card">
  <h3>抽出ログ</h3>
  <ul id="log" class="log"></ul>
</div>

<script>
/* === 期待値 (/G) — 新ハナビ（通常時 合算） === */
const EXPECT = {
  bell:  [1/7.7,  1/7.6,  1/7.5,  1/7.3],   // 設定: 1,2,5,6
  cherry:[1/16.4, 1/15.3, 1/16.1, 1/15.6],
  ice:   [1/51.2, 1/51.8, 1/48.2, 1/49.3],
};
/* 合算・BB/RT/RB の“分母レンジ/期待値” */
const RANGE = {
  bell:   [4.5, 10.5],   // 1/7.x 付近
  cherry: [10,  25],     // 1/15.x 付近
  ice:    [35,  80],     // 1/50〜60 付近
  bb_slant:[7,  13],     // BB斜め風鈴 ~9 or 11
  bb_rare: [400, 30000], // バラケ目（6は ~655）
  rt_hc:   [4.6, 6.6],   // 花火チャレンジ中はずれ
  rt_hg:   [8.5, 14.5],  // 花火GAME中はずれ
};
const EXPECT_DENOM = {
  bb_slant: {1:11.0, 2:9.0, 5:11.0, 6:9.0},
  bb_rare:  {1:16384,2:16384,5:16384,6:655.4},
  rt_hc_miss:{1:6.0,  2:5.8,  5:5.3,  6:5.1},
  rt_hg_miss:{1:13.4, 2:12.4, 5:10.1, 6:9.5}
};
const WEIGHTS = { bell:1.0, cherry:1.0, ice:0.7, bb_slant:1.1, bb_rare:2.2, rt_hc_miss:1.0, rt_hg_miss:1.0, rb_miss:1.6 };

const state = {
  metrics:{games:undefined,bell:undefined,cherry:undefined,ice:undefined},
  extra:{bb_slant_den:null, bb_rare_den:null, rt_hc_den:null, rt_hg_den:null, rb_miss_count:null},
  flags:{peace:false, edit:false},
  log:[]
};

/* ---------- Utils ---------- */
const $ = (id)=>document.getElementById(id);
function toNum(x){ if(x==null) return undefined; const n=Number(String(x).replace(/,/g,'')); return Number.isFinite(n)?n:undefined; }
function pushLog(msg){ state.log.push(msg); }
function setError(msg){ const e=$("err"); e.style.display=msg?"block":"none"; e.textContent=msg||""; }
function setText(id, s, mutedWhenDash=true){
  const el=$(id); el.textContent=s;
  if(mutedWhenDash) el.classList.toggle("muted", s==="—");
}

/* サニタイズ */
function sanitize(s){
  return (s||"")
    .replace(/[０-９]/g, d=>String.fromCharCode(d.charCodeAt(0)-0xFEE0))
    .replace(/[，]/g, ",").replace(/[．]/g, ".")
    .replace(/[：:]\s*/g, ": ")
    .replace(/[　]/g, " ")
    .replace(/[／]/g, "/")
    .replace(/\s+\/\s+/g, "/")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/* ===== 行連結（OCRの見出し割れ修正） ===== */
function coalesceLines(lines){
  const out=[];
  for(let i=0;i<lines.length;i++){
    let cur=lines[i];

    if(/^(風鈴|チェリー|氷)\s*$/.test(cur) && i+1<lines.length && /^合算\s*$/.test(lines[i+1])){
      out.push(RegExp.$1 + "合算"); i++; continue;
    }
    if(/^花火チャレンジ中\s*$/.test(cur) && i+1<lines.length && /^(?:はずれ|ハズレ)\s*$/.test(lines[i+1])){
      out.push("花火チャレンジ中はずれ"); i++; continue;
    }
    if(/^花火GAME中\s*$/.test(cur) && i+1<lines.length && /^(?:はずれ|ハズレ)\s*$/.test(lines[i+1])){
      out.push("花火GAME中はずれ"); i++; continue;
    }
    if(/^レア役\s*$/.test(cur) && i+1<lines.length && /[()（].*バラケ目.*[)）]\s*$/.test(lines[i+1])){
      out.push("レア役（バラケ目）"); i++; continue;
    }
    out.push(cur);
  }
  return out;
}

/* パターン */
const RE_G_ONLY   = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*G\s*$/i;
const RE_KAI_LIKE = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*(?:回|囘|问|n)\s*$/i;
const RE_FRAC_ANY = /[1Iｌl]\s*\/\s*([0-9][0-9,]*(?:\.[0-9]+)?)/;

function countFrac(line){
  const c=line.match(RE_KAI_LIKE);
  const f=line.match(RE_FRAC_ANY);
  const denom=f?parseFloat(f[1].replace(/,/g,'')):undefined;
  return { count:c?toNum(c[1]):undefined, denom };
}

/* 文書全体の「回+1/◯」候補 */
function collectAllPairs(lines){
  const pairs=[];
  for(let i=0;i<lines.length;i++){
    const {count,denom}=countFrac(lines[i]);
    if(count!=null && denom!=null){ pairs.push({idx:i,count,denom}); continue; }
    const c=lines[i].match(RE_KAI_LIKE);
    const f=(i+1<lines.length)?lines[i+1].match(RE_FRAC_ANY):null;
    if(c && f){ pairs.push({idx:i,count:toNum(c[1]),denom:parseFloat(f[1].replace(/,/g,''))}); i++; }
  }
  pushLog(`pairs: ${pairs.length}件収集`);
  return pairs;
}

/* 近傍探索 */
function pickNearBy(lines, labelIdx, window, range){
  if(labelIdx<0) return null;
  const [lo,hi]=range;
  let best=null, bestDist=1e9;
  for(let j=Math.max(0,labelIdx-window); j<Math.min(lines.length,labelIdx+window+1); j++){
    const {count,denom}=countFrac(lines[j]);
    if(count!=null && Number.isFinite(denom) && denom>=lo && denom<=hi){
      const dist=Math.abs(j-labelIdx);
      if(dist<bestDist){ best={count,denom,idx:j}; bestDist=dist; }
    }else{
      const c=lines[j].match(RE_KAI_LIKE);
      const f=(j+1<lines.length)?lines[j+1].match(RE_FRAC_ANY):null;
      if(c && f){
        const cnt=toNum(c[1]); const den=parseFloat(f[1].replace(/,/g,''));
        if(cnt!=null && Number.isFinite(den) && den>=lo && den<=hi){
          const dist=Math.abs(j-labelIdx);
          if(dist<bestDist){ best={count:cnt,denom:den,idx:j}; bestDist=dist; }
        }
      }
    }
  }
  return best;
}

/* ラベル→近傍→全体フォールバック */
function resolveMetric(lines, labelRegex, range, labelName, globalPairs){
  const idx=lines.findIndex(l=>labelRegex.test(l));
  let got=pickNearBy(lines, idx, 8, range);
  if(!got){
    const [lo,hi]=range;
    const expects = EXPECT[labelName]?.map(v=>1/v) ?? [];
    let best=null, bestScore=Infinity;
    for(const p of globalPairs){
      if(p.denom<lo || p.denom>hi) continue;
      const d = expects.length? Math.min(...expects.map(ex=>Math.abs(ex - p.denom))) : 0;
      const score = d + 0.0001*Math.abs((idx>=0?idx:p.idx)-p.idx);
      if(score<bestScore){ best=p; bestScore=score; }
    }
    got=best||null;
    if(got) pushLog(`${labelName}: fallback採用 idx=${got.idx} → ${got.count}回 (1/${got.denom})`);
  }else{
    pushLog(`${labelName}: 近傍採用 idx=${got.idx} → ${got.count}回 (1/${got.denom})`);
  }
  return got;
}

/* === 解析本体 === */
function parseMetricsFromText(raw){
  state.log = [];
  const t = sanitize(raw);
  const rawLines = t.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const lines = coalesceLines(rawLines);

  const out = {games:undefined,bell:undefined,cherry:undefined,ice:undefined};
  const extra = {bb_slant_den:null, bb_rare_den:null, rt_hc_den:null, rt_hg_den:null, rb_miss_count:null};

  // 総G：G-only最大
  const cands = lines.map(ln=>{ const m=RE_G_ONLY.exec(ln); return m?toNum(m[1]):null; }).filter(v=>v!=null);
  if(cands.length){ out.games = Math.max(...cands); pushLog(`総G: G-only最大 → ${out.games}`); } else pushLog("総G: 見つからず");

  // 全体ペア
  const allPairs = collectAllPairs(lines);

  // 合算3種
  const bell   = resolveMetric(lines, /風鈴\s*合算/, RANGE.bell,   "bell",   allPairs);
  const cherry = resolveMetric(lines, /チェリー\s*合算/, RANGE.cherry, "cherry", allPairs);
  const ice    = resolveMetric(lines, /氷\s*合算/,    RANGE.ice,    "ice",    allPairs);

  if(bell){ out.bell=bell.count; pushLog(`風鈴合算= ${out.bell}回 1/${bell.denom}`); }
  if(cherry){ out.cherry=cherry.count; pushLog(`チェリー合算= ${out.cherry}回 1/${cherry.denom}`); }
  if(ice){ out.ice=ice.count; pushLog(`氷合算= ${out.ice}回 1/${ice.denom}`); }

  // 追加シグナル（近傍のみ）
  const bbSlant = pickNearBy(lines, lines.findIndex(l=>/(風斜め揃い|斜め風鈴|風鈴B|風鈴中段揃)/.test(l)), 6, RANGE.bb_slant);
  if(bbSlant){ extra.bb_slant_den = bbSlant.denom; pushLog(`BB斜め風鈴= 1/${extra.bb_slant_den}`); }

  const bbRare = pickNearBy(lines, lines.findIndex(l=>/(レア役|バラケ目)/.test(l)), 6, RANGE.bb_rare);
  if(bbRare){ extra.bb_rare_den = bbRare.denom; pushLog(`BBレア役(=バラケ目)= 1/${extra.bb_rare_den}`); }

  const rtHC = pickNearBy(lines, lines.findIndex(l=>/花火チャレンジ中はずれ/.test(l)), 6, RANGE.rt_hc);
  if(rtHC){ extra.rt_hc_den = rtHC.denom; pushLog(`HCはずれ= 1/${extra.rt_hc_den}`); }

  const rtHG = pickNearBy(lines, lines.findIndex(l=>/花火GAME中はずれ/.test(l)), 6, RANGE.rt_hg);
  if(rtHG){ extra.rt_hg_den = rtHG.denom; pushLog(`HGはずれ= 1/${extra.rt_hg_den}`); }

  // RB中ハズレ（“RB中”ラベル近傍）
  const rbIdx = lines.findIndex(l=>/(RB中詳細|RB中詳)/.test(l));
  if(rbIdx>=0){
    // 回数だけ見る（分母はない前提）
    for(let j=Math.max(0,rbIdx-8); j<Math.min(lines.length,rbIdx+9); j++){
      const c = lines[j].match(RE_KAI_LIKE);
      if(c){ extra.rb_miss_count = toNum(c[1]); pushLog(`RB中ハズレ= ${extra.rb_miss_count}回`); break; }
    }
  }

  state.extra = extra;
  updateSignals(extra);
  pushLog(`summary: bell=${out.bell??"-"} | cherry=${out.cherry??"-"} | ice=${out.ice??"-"} | bb_slant=1/${extra.bb_slant_den??"-"} | bb_rare=1/${extra.bb_rare_den??"-"} | hc=1/${extra.rt_hc_den??"-"} | hg=1/${extra.rt_hg_den??"-"} | rb_miss=${extra.rb_miss_count??"-"}`);

  return out;
}

/* ---------- 推測（尤度ベース：二項ログ尤度 + 追加指標のガウス罰則） ---------- */
function estimateAllSettings(m){
  const g = toNum(m.games)||0; if(!g) return [];
  const EPS=1e-9, clamp01=(p)=>Math.min(1-EPS,Math.max(EPS,p));
  const ll_binom=(k,n,p)=>{p=clamp01(p); const q=1-p; return k*Math.log(p)+(n-k)*Math.log(q);};
  const penalty_denom=(d,exp,w)=>(!Number.isFinite(d)||!Number.isFinite(exp))?0:(-w*Math.pow((d-exp)/exp,2)/(2*Math.pow(0.12,2)));

  const have={bell:Number.isFinite(toNum(m.bell)),cherry:Number.isFinite(toNum(m.cherry)),ice:Number.isFinite(toNum(m.ice))};
  const settings=[1,2,5,6];
  const rows=settings.map((s,i)=>{
    let ll=0, used=0;
    if(have.bell){ ll+=WEIGHTS.bell*ll_binom(toNum(m.bell), g, EXPECT.bell[i]); used++; }
    if(have.cherry){ ll+=WEIGHTS.cherry*ll_binom(toNum(m.cherry), g, EXPECT.cherry[i]); used++; }
    if(have.ice){ ll+=WEIGHTS.ice*ll_binom(toNum(m.ice), g, EXPECT.ice[i]); used++; }
    if(state.extra.bb_slant_den){ ll+=penalty_denom(state.extra.bb_slant_den, EXPECT_DENOM.bb_slant[s], WEIGHTS.bb_slant); used++; }
    if(state.extra.bb_rare_den){ ll+=penalty_denom(state.extra.bb_rare_den, EXPECT_DENOM.bb_rare[s], WEIGHTS.bb_rare); used++; }
    if(state.extra.rt_hc_den){ ll+=penalty_denom(state.extra.rt_hc_den, EXPECT_DENOM.rt_hc_miss[s], WEIGHTS.rt_hc_miss); used++; }
    if(state.extra.rt_hg_den){ ll+=penalty_denom(state.extra.rt_hg_den, EXPECT_DENOM.rt_hg_miss[s], WEIGHTS.rt_hg_miss); used++; }
    if(state.extra.rb_miss_count!=null){
      const miss=state.extra.rb_miss_count;
      if((s===1||s===2)&&miss>0){ ll -= WEIGHTS.rb_miss*(1+miss); used++; }
      if((s===5||s===6)&&miss>0){ ll += WEIGHTS.rb_miss*Math.min(1,miss*0.2); used++; }
    }
    // ピースマーク → 設定1排除
    if(s===1 && state.flags.peace){ ll = -Infinity; used++; }
    return {setting:s, ll: used? ll : -Infinity};
  });

  const maxLL=Math.max(...rows.map(r=>r.ll));
  const expS=rows.map(r=>Math.exp(r.ll-maxLL));
  const sumS=expS.reduce((a,b)=>a+b,0)||1;
  return rows.map((r,i)=>({setting:r.setting, score:expS[i], percent:(expS[i]/sumS)*100}));
}

/* ---------- UI ---------- */
function barColor(p,max,min){
  if(max===min) return "rgba(96,165,250,0.85)";
  if(p===max) return "rgba(239,68,68,0.85)";
  if(p===min) return "rgba(147,197,253,0.85)";
  const t=(p-min)/Math.max(1,(max-min));
  const r=Math.round(147+(59-147)*t), g=Math.round(197+(130-197)*t), b=Math.round(253+(246-253)*t);
  return `rgba(${r},${g},${b},0.9)`;
}
function renderBars(){
  const mount=$("bars");
  const rows=estimateAllSettings(state.metrics);
  if(!rows.length){ mount.textContent="必要な数値が揃うと比較グラフが表示されます。"; return; }
  const perc=rows.map(r=>r.percent), max=Math.max(...perc), min=Math.min(...perc);
  mount.innerHTML="";
  rows.forEach(r=>{
    const head=document.createElement("div"); head.className="rowline";
    head.innerHTML=`<span>新ハナビ｜設定${r.setting}</span><span>${r.percent.toFixed(2)}%</span>`;
    const barWrap=document.createElement("div"); barWrap.className="bar-wrap";
    const bar=document.createElement("div"); bar.className="bar";
    bar.style.width = Math.max(0, Math.min(100, isFinite(r.percent)? r.percent : 0)) + "%";
    bar.style.background = barColor(r.percent,max,min);
    barWrap.appendChild(bar);
    mount.appendChild(head); mount.appendChild(barWrap);
  });
}
function updateSignals(ex){
  setText("sig-bb-slant", ex.bb_slant_den? `1/${ex.bb_slant_den}` : "—");
  setText("sig-bb-rare",  ex.bb_rare_den ? `1/${ex.bb_rare_den}`  : "—");
  setText("sig-rt-hc",    ex.rt_hc_den   ? `1/${ex.rt_hc_den}`    : "—");
  setText("sig-rt-hg",    ex.rt_hg_den   ? `1/${ex.rt_hg_den}`    : "—");
  setText("sig-rb-miss",  Number.isFinite(ex.rb_miss_count)? `${ex.rb_miss_count}回` : "—");
}

const METRIC_KEYS=["games","bell","cherry","ice"];
const METRIC_LABEL={games:"総G", bell:"風鈴合算（回）", cherry:"チェリー合算（回）", ice:"氷合算（回）"};
function renderMetrics(firstRender=false){
  const wrap=$("metrics");
  if(firstRender){ // 初回だけDOM構築。以降は値とdisabledだけ更新してフォーカスを守る
    wrap.innerHTML="";
    METRIC_KEYS.forEach(k=>{
      const row=document.createElement("label"); row.style.display="flex"; row.style.alignItems="center"; row.style.gap="8px";
      const keySpan=document.createElement("span"); keySpan.className="key"; keySpan.textContent=METRIC_LABEL[k]; row.appendChild(keySpan);
      const input=document.createElement("input"); input.type="number"; input.step="1"; input.id=`inp-${k}`;
      input.value = state.metrics[k]??"";
      input.oninput=(e)=>{
        if(!state.flags.edit) return;
        const v = e.target.value==="" ? undefined : toNum(e.target.value);
        state.metrics[k]=v;
        // 入力中は再レンダしない→フォーカス保持、バーのみ更新
        renderBars();
        updatePerG(k);
      };
      input.onblur=()=>{ renderMetrics(false); }; // フォーカス抜けたら全体同期
      row.appendChild(input);
      const tail=document.createElement("span"); tail.className="perg"; tail.id=`perg-${k}`; row.appendChild(tail);
      wrap.appendChild(row);
    });
  }
  // 値＆disabled更新
  METRIC_KEYS.forEach(k=>{
    const input=$(`inp-${k}`);
    if(document.activeElement!==input){ input.value = state.metrics[k]??""; }
    input.disabled = !state.flags.edit;
    updatePerG(k);
  });

  // ログ
  const ul = $("log"); ul.innerHTML = "";
  state.log.slice(-30).forEach(msg=>{ const li=document.createElement("li"); li.textContent=msg; ul.appendChild(li); });
}
function updatePerG(k){
  const span=$(`perg-${k}`);
  if(k!=="games" && toNum(state.metrics.games)){
    const per=(toNum(state.metrics[k])||0)/toNum(state.metrics.games);
    span.textContent = Number.isFinite(per) ? "/G "+per.toFixed(4) : "";
  }else span.textContent="";
}

/* ---------- init ---------- */
function init(){
  renderMetrics(true); renderBars();
  $("btn-parse").addEventListener("click", ()=>{
    try{
      setError("");
      state.metrics = parseMetricsFromText($("text").value||"");

      if(!toNum(state.metrics.games)){
        setError("総G（例: 6,056G）が見つかりませんでした。");
      }else{
        const got=["bell","cherry","ice"].filter(k=>toNum(state.metrics[k])!=null);
        if(got.length===0) setError("『風鈴合算／チェリー合算／氷合算』が見つかりませんでした。");
      }
      renderMetrics(false); renderBars();
    }catch(err){ setError("解析中にエラー: "+(err&&err.message?err.message:String(err))); }
  });

  $("edit-mode").addEventListener("change",(e)=>{ state.flags.edit = e.target.checked; renderMetrics(false); });
  $("peace").addEventListener("change",(e)=>{ state.flags.peace = e.target.checked; renderBars(); });

  // デモ用自己テスト（必要なら削除OK）
  const sample = `新ハナビ
基本情報
総プレイ数
小役
風鈴
合算
氷
合算
チェリー
合算
BB中詳細
風斜め揃い
レア役
RT
花火チャレンジ中
はずれ
花火GAME中
はずれ
6,056G
813回
1/7.4
103回
1/58.8
393回
1/15.4`;
  state.metrics = parseMetricsFromText(sample);
  renderMetrics(false); renderBars();
}
init();
</script>
</body>
</html>
