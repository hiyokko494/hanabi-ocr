<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>04-2025.09.11現在、機能追加中につき正常に動作しません：特リプTV｜新ハナビ 専用（安定抽出・修正）</title>
<style>
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;margin:24px;color:#111}
  h1{font-size:20px;margin:0 0 12px}
  .hint{background:#fff7ed;border:1px solid #fed7aa;color:#7c2d12;padding:8px 10px;border-radius:8px;font-size:13px}
  .error{background:#fef2f2;border:1px solid #fecaca;color:#991b1b;padding:8px 10px;border-radius:8px;font-size:13px;margin-top:8px;display:none}
  .card{background:#f9fafb;border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin-top:12px}
  .card h3{margin:0 0 8px;font-size:14px}
  textarea{width:100%;height:200px;border:1px solid #e5e7eb;border-radius:8px;padding:8px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:8px}
  @media(min-width:640px){.grid{grid-template-columns:1fr 1fr}}
  label span.key{width:120px;color:#374151;display:inline-block}
  input[type="number"]{border:1px solid #e5e7eb;border-radius:6px;padding:6px 8px;width:100%}
  .perg{font-size:11px;color:#6b7280;width:100px;text-align:right}
  .bar-wrap{width:100%;height:16px;background:#e5e7eb;border-radius:999px;overflow:hidden}
  .bar{height:16px;transition:width .3s ease}
  .rowline{display:flex;align-items:center;justify-content:space-between;font-size:12px;margin-bottom:4px}
  ul.log{margin:6px 0 0 18px;padding:0;font-size:12px;line-height:1.4}
</style>
</head>
<body>
<h1>04-2025.09.11現在、機能追加中につき正常に動作しません：特リプTV｜新ハナビ 専用（安定抽出・修正）</h1>
<div class="hint">
  貼ったテキストを<strong>行内</strong>→<strong>見出しから末尾までの後方スキャン</strong>の順で解析します。<br>
  総Gは<b>「◯◯G」だけの行</b>を候補にし<b>最大値</b>を採用。OCRの行割れ（例：<code>チェリー⏎合算</code>）は自動結合してから解析します。
</div>

<div id="err" class="error"></div>

<div class="card">
  <div style="display:flex;align-items:center;justify-content:space-between;">
    <h3>テキスト（手動貼り付け）</h3>
    <button id="btn-parse" class="btn" style="background:#2563eb;color:#fff;">テキストから解析</button>
  </div>
  <textarea id="text" placeholder="総プレイ数：6,056G
風鈴合算：813回 1/7.4
チェリー
合算：381回 1/15.9
氷
合算：103回 1/58.8"></textarea>
</div>

<div class="card">
  <h3>抽出メトリクス（編集可）</h3>
  <div class="grid" id="metrics"></div>
  <div id="logbox">
    <h3 style="margin-top:10px">抽出ログ</h3>
    <ul id="log" class="log"></ul>
  </div>
</div>

<div class="card">
  <h3>推測比較（最大=赤、最小=水色／同値は中間色）</h3>
  <div id="bars">必要な数値が揃うと比較グラフが表示されます。</div>
</div>

<script>
/* === 期待値 (/G) — 新ハナビ（通常時 合算） === */
const EXPECT = {
  bell:  [1/7.7,  1/7.6,  1/7.5,  1/7.3],   // 設定: 1,2,5,6
  cherry:[1/16.4, 1/15.3, 1/16.1, 1/15.6],
  ice:   [1/51.2, 1/51.8, 1/48.2, 1/49.3],
};
/* 合算・BB/RT/RB の“分母レンジ/期待値” */
const RANGE = {
  bell:   [4.5, 10.5],    // 1/7.x 付近
  cherry: [10,  25],      // 1/15.x 付近
  ice:    [35,  80],      // 1/50〜60 付近
  bb_slant:[7,  13],      // BB斜め風鈴 ~9 or 11
  bb_rare: [400, 30000],  // バラケ目（6以外はほぼ1/16384、6は~655）
  rt_hc:   [4.6, 6.6],    // 花火チャレンジ中はずれ
  rt_hg:   [8.5, 14.5],   // 花火GAME中はずれ
};
const EXPECT_DENOM = {
  bb_slant: {1:11.0, 2:9.0, 5:11.0, 6:9.0},
  bb_rare:  {1:16384,2:16384,5:16384,6:655.4},
  rt_hc_miss:{1:6.0,  2:5.8,  5:5.3,  6:5.1},
  rt_hg_miss:{1:13.4, 2:12.4, 5:10.1, 6:9.5}
};
const WEIGHTS = { bell:1.0, cherry:1.0, ice:0.7, bb_slant:1.1, bb_rare:2.2, rt_hc_miss:1.0, rt_hg_miss:1.0, rb_miss:1.6 };

const state = {
  metrics:{games:undefined,bell:undefined,cherry:undefined,ice:undefined},
  extra:{bb_slant_den:null, bb_rare_den:null, rt_hc_den:null, rt_hg_den:null, rb_miss_count:null},
  log:[]
};

/* ---------- Utils ---------- */
function toNum(x){ if(x==null) return undefined; const n=Number(String(x).replace(/,/g,'')); return Number.isFinite(n)?n:undefined; }
function pushLog(msg){ state.log.push(msg); }
function setError(msg){ const e=document.getElementById("err"); e.style.display=msg?"block":"none"; e.textContent=msg||""; }

function sanitize(s){
  return (s||"")
    .replace(/[０-９]/g, d=>String.fromCharCode(d.charCodeAt(0)-0xFEE0))
    .replace(/[，]/g, ",").replace(/[．]/g, ".")
    .replace(/[：:]\s*/g, ": ")
    .replace(/[　]/g, " ")
    .replace(/[／]/g, "/")
    .replace(/\s+\/\s+/g, "/")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/* ===== 行連結（OCRの見出し割れ修正） ===== */
function coalesceLines(lines){
  const out=[];
  for(let i=0;i<lines.length;i++){
    let cur=lines[i];

    if(/^(風鈴|チェリー|氷)\s*$/.test(cur) && i+1<lines.length && /^合算\s*$/.test(lines[i+1])){
      out.push(RegExp.$1 + "合算"); i++; continue;
    }
    if(/^花火チャレンジ中\s*$/.test(cur) && i+1<lines.length && /^(?:はずれ|ハズレ)\s*$/.test(lines[i+1])){
      out.push("花火チャレンジ中はずれ"); i++; continue;
    }
    if(/^花火GAME中\s*$/.test(cur) && i+1<lines.length && /^(?:はずれ|ハズレ)\s*$/.test(lines[i+1])){
      out.push("花火GAME中はずれ"); i++; continue;
    }
    if(/^レア役\s*$/.test(cur) && i+1<lines.length && /[()（].*バラケ目.*[)）]\s*$/.test(lines[i+1])){
      out.push("レア役（バラケ目）"); i++; continue;
    }
    out.push(cur);
  }
  return out;
}

/* パターン（OCRゆらぎに寛容に） */
const RE_G_ONLY   = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*G\s*$/i;
/* 回数: 回|囘|问|n を許容（語尾の単独 n を “回” 誤読とみなす） */
const RE_KAI_LIKE = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*(?:回|囘|问|n)\s*$/i;
/* 分母: カンマ入りも許容 → 数値化時に除去 */
const RE_FRAC_ANY = /[1Iｌl]\s*\/\s*([0-9][0-9,]*(?:\.[0-9]+)?)/;

/* 行→ {count,denom} 取得 */
function countFrac(line){
  const c = line.match(RE_KAI_LIKE);
  const f = line.match(RE_FRAC_ANY);
  const denom = f ? parseFloat(f[1].replace(/,/g,'')) : undefined;
  return { count: c?toNum(c[1]):undefined, denom };
}

/* 文書全体の「回+1/◯」候補を収集 */
function collectAllPairs(lines){
  const pairs=[];
  for(let i=0;i<lines.length;i++){
    const {count,denom} = countFrac(lines[i]);
    if(count!=null && denom!=null){ pairs.push({idx:i,count,denom}); continue; }
    const c = lines[i].match(RE_KAI_LIKE);
    const f = (i+1<lines.length) ? lines[i+1].match(RE_FRAC_ANY) : null;
    if(c && f){ pairs.push({idx:i, count:toNum(c[1]), denom:parseFloat(f[1].replace(/,/g,''))}); i++; }
  }
  pushLog(`pairs: ${pairs.length}件収集`);
  return pairs;
}

/* 近傍探索: ラベル行 index を起点に前後 window 行を走査し、レンジに入る分母の最小距離を採用 */
function pickNearBy(lines, labelIdx, window, range){
  if(labelIdx<0) return null;
  const [lo,hi] = range;
  let best=null, bestDist=1e9;
  for(let j=Math.max(0,labelIdx-window); j<Math.min(lines.length,labelIdx+window+1); j++){
    const {count,denom} = countFrac(lines[j]);
    if(count!=null && Number.isFinite(denom) && denom>=lo && denom<=hi){
      const dist = Math.abs(j-labelIdx);
      if(dist<bestDist){ best={count,denom,idx:j}; bestDist=dist; }
    }else{
      // 行+次行ペア
      const c = lines[j].match(RE_KAI_LIKE);
      const f = (j+1<lines.length) ? lines[j+1].match(RE_FRAC_ANY) : null;
      if(c && f){
        const cnt = toNum(c[1]); const den = parseFloat(f[1].replace(/,/g,''));
        if(cnt!=null && Number.isFinite(den) && den>=lo && den<=hi){
          const dist = Math.abs(j-labelIdx);
          if(dist<bestDist){ best={count:cnt,denom:den,idx:j}; bestDist=dist; }
        }
      }
    }
  }
  return best;
}

/* ラベル→近傍探索→（無ければ）全体フォールバック */
function resolveMetric(lines, labelRegex, range, labelName, globalPairs){
  // ラベルの位置（複数あれば最初）
  const idx = lines.findIndex(l=>labelRegex.test(l));
  let got = pickNearBy(lines, idx, 8, range);  // 近傍 ±8行 で探索
  if(!got){ // 全体フォールバック（分母レンジで最も近いもの）
    const [lo,hi] = range;
    let best=null, bestScore=Infinity;
    for(const p of globalPairs){
      if(p.denom<lo || p.denom>hi) continue;
      // 期待分母中心のスコアリング（平均期待に近いもの優先）
      const expects = Object.values(EXPECT).includes(EXPECT[labelName]) ? EXPECT[labelName].map(v=>1/v) : null;
      const d = expects ? Math.min(...expects.map(ex=>Math.abs(ex - p.denom))) : 0;
      const score = d + 0.0001*Math.abs((idx>=0?idx:p.idx)-p.idx); // ほんの少しだけ“近さ”も加味
      if(score<bestScore){ best=p; bestScore=score; }
    }
    got = best||null;
    if(got) pushLog(`${labelName}: fallback採用 idx=${got.idx} → ${got.count}回 (1/${got.denom})`);
  }else{
    pushLog(`${labelName}: 近傍採用 idx=${got.idx} → ${got.count}回 (1/${got.denom})`);
  }
  return got;
}

/* === 解析本体 === */
function parseMetricsFromText(raw){
  state.log = [];
  const t = sanitize(raw);
  const rawLines = t.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const lines = coalesceLines(rawLines);

  const out = {games:undefined,bell:undefined,cherry:undefined,ice:undefined};
  const extra = {bb_slant_den:null, bb_rare_den:null, rt_hc_den:null, rt_hg_den:null, rb_miss_count:null};

  // 総G：G-only最大
  const cands = lines.map(ln=>{ const m=RE_G_ONLY.exec(ln); return m?toNum(m[1]):null; }).filter(v=>v!=null);
  if(cands.length){ out.games = Math.max(...cands); pushLog(`総G: G-only最大 → ${out.games}`); } else pushLog("総G: 見つからず");

  // 先に全体ペアを収集（フォールバック用）
  const allPairs = collectAllPairs(lines);

  // 合算3種：ラベル近傍→全体フォールバック（分母レンジ）
  const bell   = resolveMetric(lines, /風鈴\s*合算/, RANGE.bell,   "bell",   allPairs);
  const cherry = resolveMetric(lines, /チェリー\s*合算/, RANGE.cherry, "cherry", allPairs);
  const ice    = resolveMetric(lines, /氷\s*合算/,    RANGE.ice,    "ice",    allPairs);

  if(bell)   { out.bell   = bell.count;   pushLog(`風鈴合算= ${out.bell}回 1/${bell.denom}`); }
  if(cherry) { out.cherry = cherry.count; pushLog(`チェリー合算= ${out.cherry}回 1/${cherry.denom}`); }
  if(ice)    { out.ice    = ice.count;    pushLog(`氷合算= ${out.ice}回 1/${ice.denom}`); }

  // 追加シグナル（いずれもラベル近傍のみ採用。*分母レンジ*必須）
  const bbSlant = pickNearBy(lines, lines.findIndex(l=>/(風斜め揃い|斜め風鈴|風鈴B|風鈴中段揃)/.test(l)), 6, RANGE.bb_slant);
  if(bbSlant){ extra.bb_slant_den = bbSlant.denom; pushLog(`BB斜め風鈴= 1/${extra.bb_slant_den}`); }

  const bbRare  = pickNearBy(lines, lines.findIndex(l=>/(レア役|バラケ目)/.test(l)), 6, RANGE.bb_rare);
  if(bbRare){ extra.bb_rare_den = bbRare.denom; pushLog(`BBレア役(=バラケ目)= 1/${extra.bb_rare_den}`); }

  const rtHC    = pickNearBy(lines, lines.findIndex(l=>/花火チャレンジ中はずれ/.test(l)), 6, RANGE.rt_hc);
  if(rtHC){ extra.rt_hc_den = rtHC.denom; pushLog(`HCはずれ= 1/${extra.rt_hc_den}`); }

  const rtHG    = pickNearBy(lines, lines.findIndex(l=>/花火GAME中はずれ/.test(l)), 6, RANGE.rt_hg);
  if(rtHG){ extra.rt_hg_den = rtHG.denom; pushLog(`HGはずれ= 1/${extra.rt_hg_den}`); }

  // RB中ハズレ（“RB中”のラベル近傍のみ）
  const rbIdx = lines.findIndex(l=>/(RB中詳細|RB中詳)/.test(l));
  if(rbIdx>=0){
    const got = pickNearBy(lines, rbIdx, 8, [0, 1e9]); // 回数のみ重視
    if(got && got.count!=null){ extra.rb_miss_count = got.count; pushLog(`RB中ハズレ= ${extra.rb_miss_count}回`); }
  }

  state.extra = extra;
  pushLog(`summary: bell=${out.bell??"-"} | cherry=${out.cherry??"-"} | ice=${out.ice??"-"} | bb_slant=1/${extra.bb_slant_den??"-"} | bb_rare=1/${extra.bb_rare_den??"-"} | hc=1/${extra.rt_hc_den??"-"} | hg=1/${extra.rt_hg_den??"-"} | rb_miss=${extra.rb_miss_count??"-"}`);
  return out;
}

/* ---------- 推測（尤度ベース：二項ログ尤度 + 追加指標のガウス罰則） ---------- */
function estimateAllSettings(m){
  const g = toNum(m.games)||0; if(!g) return [];

  // 尤度用の小さすぎる値対策
  const EPS = 1e-9;
  const clamp01 = (p)=> Math.min(1-EPS, Math.max(EPS, p));

  // 尤度（log）を器用に合算する
  function ll_binom(k, n, p){ // 定数項C(n,k)は比較では共通なので省略
    p = clamp01(p);
    const q = 1 - p;
    return k*Math.log(p) + (n-k)*Math.log(q);
  }
  // 分母系（期待分母exp、観測分母d）を“ずれ”のガウス罰則にする（= log尤度にマイナス加点）
  function penalty_denom(d, exp, weight){
    if(!Number.isFinite(d) || !Number.isFinite(exp)) return 0;
    const z = (d-exp)/exp;                 // 相対誤差
    const sigma = 0.12;                    // 12% 程度の幅（必要に応じて微調整）
    const pen = - weight * (z*z)/(2*sigma*sigma);
    return pen;
  }

  const have = {
    bell:   Number.isFinite(toNum(m.bell)),
    cherry: Number.isFinite(toNum(m.cherry)),
    ice:    Number.isFinite(toNum(m.ice))
  };

  const settings=[1,2,5,6];
  const rows = settings.map((s,i)=>{
    let ll = 0, used = 0;

    // 通常時3種：二項ログ尤度
    if(have.bell){
      const k = toNum(m.bell);
      const p = EXPECT.bell[i];
      ll += WEIGHTS.bell * ll_binom(k, g, p); used++;
    }
    if(have.cherry){
      const k = toNum(m.cherry);
      const p = EXPECT.cherry[i];
      ll += WEIGHTS.cherry * ll_binom(k, g, p); used++;
    }
    if(have.ice){
      const k = toNum(m.ice);
      const p = EXPECT.ice[i];
      ll += WEIGHTS.ice * ll_binom(k, g, p); used++;
    }

    // 追加シグナル（分母系）：ガウス罰則（= より期待に近いほど ll が高くなる）
    if(state.extra.bb_slant_den){
      ll += penalty_denom(state.extra.bb_slant_den, EXPECT_DENOM.bb_slant[s], WEIGHTS.bb_slant);
      used++;
    }
    if(state.extra.bb_rare_den){
      ll += penalty_denom(state.extra.bb_rare_den,  EXPECT_DENOM.bb_rare[s],  WEIGHTS.bb_rare);
      used++;
    }
    if(state.extra.rt_hc_den){
      ll += penalty_denom(state.extra.rt_hc_den,    EXPECT_DENOM.rt_hc_miss[s], WEIGHTS.rt_hc_miss);
      used++;
    }
    if(state.extra.rt_hg_den){
      ll += penalty_denom(state.extra.rt_hg_den,    EXPECT_DENOM.rt_hg_miss[s], WEIGHTS.rt_hg_miss);
      used++;
    }
    // RB中ハズレ：1,2で出たら大減点／5,6は微ご褒美（penaltyを符号で表現）
    if(state.extra.rb_miss_count!=null){
      const miss = state.extra.rb_miss_count;
      if((s===1 || s===2) && miss>0){ ll -= WEIGHTS.rb_miss * (1 + miss); used++; }
      if((s===5 || s===6) && miss>0){ ll += WEIGHTS.rb_miss * Math.min(1, miss*0.2); used++; }
    }

    // usedが全く無い安全弁
    return {setting:s, ll: used ? ll : -Infinity};
  });

  // softmaxで確率化（数値安定化のため max を引く）
  const maxLL = Math.max(...rows.map(r=>r.ll));
  const expS  = rows.map(r=> Math.exp(r.ll - maxLL));
  const sumS  = expS.reduce((a,b)=>a+b,0) || 1;

  return rows.map((r,idx)=>({
    setting: r.setting,
    score:   expS[idx],
    percent: (expS[idx]/sumS)*100
  }));
}

/* ---------- UI ---------- */
function barColor(p,max,min){
  if(max===min) return "rgba(96,165,250,0.85)";
  if(p===max) return "rgba(239,68,68,0.85)";
  if(p===min) return "rgba(147,197,253,0.85)";
  const t=(p-min)/Math.max(1,(max-min));
  const r=Math.round(147+(59-147)*t), g=Math.round(197+(130-197)*t), b=Math.round(253+(246-253)*t);
  return `rgba(${r},${g},${b},0.9)`;
}
function renderMetrics(){
  const wrap=document.getElementById("metrics"); wrap.innerHTML="";
  const keys=["games","bell","cherry","ice"];
  const label={games:"総G", bell:"風鈴合算", cherry:"チェリー合算", ice:"氷合算"};
  keys.forEach(k=>{
    const row=document.createElement("label"); row.style.display="flex"; row.style.alignItems="center"; row.style.gap="8px";
    const keySpan=document.createElement("span"); keySpan.className="key"; keySpan.textContent=label[k]; row.appendChild(keySpan);
    const input=document.createElement("input"); input.type="number"; input.step="1";
    input.value = (state.metrics[k]??"");
    input.oninput=e=>{
      const v = e.target.value==="" ? undefined : toNum(e.target.value);
      state.metrics[k]=v; renderBars(); renderMetrics();
    };
    row.appendChild(input);
    const tail=document.createElement("span"); tail.className="perg";
    if(k!=="games" && toNum(state.metrics.games)){
      const per=(toNum(state.metrics[k])||0)/toNum(state.metrics.games);
      tail.textContent = Number.isFinite(per) ? "/G "+per.toFixed(4) : "";
    }else tail.textContent="";
    row.appendChild(tail);
    wrap.appendChild(row);
  });
  const ul=document.getElementById("log"); ul.innerHTML="";
  state.log.slice(-24).forEach(msg=>{ const li=document.createElement("li"); li.textContent=msg; ul.appendChild(li); });
}
function renderBars(){
  const mount=document.getElementById("bars");
  const rows=estimateAllSettings(state.metrics);
  if(!rows.length){ mount.textContent="必要な数値が揃うと比較グラフが表示されます。"; return; }
  const perc=rows.map(r=>r.percent), max=Math.max(...perc), min=Math.min(...perc);
  mount.innerHTML="";
  rows.forEach(r=>{
    const head=document.createElement("div"); head.className="rowline";
    head.innerHTML=`<span>新ハナビ｜設定${r.setting}</span><span>${r.percent.toFixed(2)}%</span>`;
    const barWrap=document.createElement("div"); barWrap.className="bar-wrap";
    const bar=document.createElement("div"); bar.className="bar";
    bar.style.width = Math.max(0, Math.min(100, isFinite(r.percent)? r.percent : 0)) + "%";
    bar.style.background = barColor(r.percent,max,min);
    barWrap.appendChild(bar);
    mount.appendChild(head); mount.appendChild(barWrap);
  });
}

/* ---------- init ---------- */
function init(){
  renderMetrics(); renderBars();
  document.getElementById("btn-parse").addEventListener("click", ()=>{
    try{
      setError("");
      const text=document.getElementById("text").value||"";
      state.metrics = parseMetricsFromText(text);
      if(!toNum(state.metrics.games)){
        setError("総G（例: 6,056G）が見つかりませんでした。");
      }else{
        const got=["bell","cherry","ice"].filter(k=>toNum(state.metrics[k])!=null);
        if(got.length===0) setError("『風鈴合算／チェリー合算／氷合算』が見つかりませんでした。");
      }
      renderMetrics(); renderBars();
    }catch(err){ setError("解析中にエラー: "+(err&&err.message?err.message:String(err))); }
  });
}
init();
</script>
</body>
</html>
