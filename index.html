<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>特リプTV｜新ハナビ 専用（安定抽出・修正）</title>
<style>
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;margin:24px;color:#111}
  h1{font-size:20px;margin:0 0 12px}
  .hint{background:#fff7ed;border:1px solid #fed7aa;color:#7c2d12;padding:8px 10px;border-radius:8px;font-size:13px}
  .error{background:#fef2f2;border:1px solid #fecaca;color:#991b1b;padding:8px 10px;border-radius:8px;font-size:13px;margin-top:8px;display:none}
  .card{background:#f9fafb;border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin-top:12px}
  .card h3{margin:0 0 8px;font-size:14px}
  textarea{width:100%;height:180px;border:1px solid #e5e7eb;border-radius:8px;padding:8px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:8px}
  @media(min-width:640px){.grid{grid-template-columns:1fr 1fr}}
  label span.key{width:120px;color:#374151;display:inline-block}
  input[type="number"]{border:1px solid #e5e7eb;border-radius:6px;padding:6px 8px;width:100%}
  .perg{font-size:11px;color:#6b7280;width:100px;text-align:right}
  .bar-wrap{width:100%;height:16px;background:#e5e7eb;border-radius:999px;overflow:hidden}
  .bar{height:16px;transition:width .3s ease}
  .rowline{display:flex;align-items:center;justify-content:space-between;font-size:12px;margin-bottom:4px}
  ul.log{margin:6px 0 0 18px;padding:0;font-size:12px;line-height:1.4}
</style>
</head>
<body>
<h1>特リプTV｜新ハナビ 専用（安定抽出・修正版 2025-09-08）</h1>
<div class="hint">
  貼ったテキストを<strong>行内</strong>→<strong>見出しから末尾までの後方スキャン</strong>の順で解析します。<br>
  総Gは<b>「◯◯G」だけの行</b>を候補にし<b>最大値</b>を採用（「100G以内…」などは無視）。<br>
  行内に「813回 1/7.4」のように回数と分母が並ぶパターンにも対応しました。
</div>

<div id="err" class="error"></div>

<div class="card">
  <div style="display:flex;align-items:center;justify-content:space-between;">
    <h3>テキスト（手動貼り付け）</h3>
    <button id="btn-parse" class="btn" style="background:#2563eb;color:#fff;">テキストから解析</button>
  </div>
  <textarea id="text" placeholder="総プレイ数：6,056G
風鈴合算：813回 1/7.4
チェリー合算：381回 1/15.9
氷合算：103回 1/58.8"></textarea>
</div>

<div class="card">
  <h3>抽出メトリクス（編集可）</h3>
  <div class="grid" id="metrics"></div>
  <div id="logbox">
    <h3 style="margin-top:10px">抽出ログ</h3>
    <ul id="log" class="log"></ul>
  </div>
</div>

<div class="card">
  <h3>推測比較（最大=赤、最小=水色／同値は中間色）</h3>
  <div id="bars">必要な数値が揃うと比較グラフが表示されます。</div>
</div>

<script>
/* === 期待値 (/G) — 新ハナビ === */
const EXPECT = {
  bell:  [1/7.7,  1/7.6,  1/7.5,  1/7.3],
  cherry:[1/16.4, 1/15.3, 1/16.1, 1/15.6],
  ice:   [1/51.2, 1/51.8, 1/48.2, 1/49.3],
};
// 期待「分母」範囲（誤紐づけ防止フィルタ）
const DENOM_RANGE = {
  bell:  [4.5, 10.5],  // 1/7.x 近辺
  cherry:[10,  25],    // 1/15.x 近辺
  ice:   [35,  80],    // 1/50〜60 近辺
};

const state = {
  metrics:{games:undefined,bell:undefined,cherry:undefined,ice:undefined},
  log:[]
};

/* ========== UTILS ========== */
function toNum(x){
  if(x==null) return undefined;
  const n = Number(String(x).replace(/,/g,''));
  return Number.isFinite(n) ? n : undefined;
}
function pushLog(msg){ state.log.push(msg); }
function sanitize(s){
  return (s||"")
    .replace(/[０-９]/g, d=>String.fromCharCode(d.charCodeAt(0)-0xFEE0))
    .replace(/[，]/g, ",").replace(/[．]/g, ".")
    .replace(/[：:]\s*/g, ": ")
    .replace(/[　]/g, " ")
    .replace(/[／]/g, "/")
    .replace(/\s+\/\s+/g, "/")
    .replace(/\s{2,}/g, " ")
    .trim();
}

const RE_G_ONLY   = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*G\s*$/i;
const RE_KAI_ONLY = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*回\s*$/;
// 1/7.4 の「1」の誤読(I/ｌ/l)も許容
const RE_FRAC_ANY = /[1Iｌl]\s*\/\s*([0-9]+(?:\.[0-9]+)?)/;

/* 同一行の「◯回 1/◯」 */
function findCountAndFracInLine(line){
  const c = line.match(/([0-9]{1,3}(?:,[0-9]{3})*)\s*回/);
  const f = line.match(RE_FRAC_ANY);
  const count = c ? toNum(c[1]) : undefined;
  const denom = f ? parseFloat(f[1]) : undefined;
  return (count!=null || denom!=null) ? {count,denom} : null;
}

/* 文書全体から「回＋1/◯」ペア候補を収集（行内 or 行+次行） */
function collectAllPairs(lines){
  const pairs = [];
  for(let i=0;i<lines.length;i++){
    const both = findCountAndFracInLine(lines[i]);
    if(both && both.count!=null && both.denom!=null){
      pairs.push({idx:i, count:both.count, denom:both.denom, kind:"inline"});
      continue;
    }
    const c = RE_KAI_ONLY.exec(lines[i]);
    if(c && i+1<lines.length){
      const f = lines[i+1].match(RE_FRAC_ANY);
      if(f){
        pairs.push({idx:i, count:toNum(c[1]), denom:parseFloat(f[1]), kind:"nextline"});
      }
    }
  }
  return pairs;
}

/* 期待値に“最も近い分母”のペアを採用（範囲外は除外） */
function pickPairForMetric(pairs, metric, games){
  const [lo,hi] = DENOM_RANGE[metric];
  const expects = EXPECT[metric].map(v=>1/v); // 分母期待値配列
  let best=null, bestScore=Infinity;

  for(const p of pairs){
    if(!(p && Number.isFinite(p.denom))) continue;
    if(p.denom<lo || p.denom>hi) continue; // 範囲外は別役と判断
    // 期待分母との差の最小値で評価
    const d = Math.min(...expects.map(ex=>Math.abs(ex - p.denom)));
    if(d<bestScore){
      bestScore = d;
      best = p;
    }
  }
  if(best){
    pushLog(`${metric}: 期待分母に最も近い候補を採用 → ${best.count}回（1/${best.denom}）`);
    return best.count;
  }

  // 分母無しで回数だけの候補が大量にあると紐付け誤りの温床になるので、基本は不採用
  // ただし行内に metric 名があって回数が拾えている等が将来あれば、ここで拾う余地を残す
  pushLog(`${metric}: 適切な候補が見つからず（分母範囲外／欠落）`);
  return undefined;
}

function parseMetricsFromText(raw){
  state.log = [];
  const t = sanitize(raw);
  const lines = t.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);

  const out = {games:undefined,bell:undefined,cherry:undefined,ice:undefined};

  // 総G：見出しが崩れても G-only 最大を優先
  const inlineGIdx = lines.findIndex(l=>/(総[ププ]レイ|総プレイ数|総ゲーム|総回転|総G数|ゲーム数|回転数)\s*[:：]?/i.test(l));
  if(inlineGIdx>=0){
    const mg = lines[inlineGIdx].match(/([0-9]{1,3}(?:,[0-9]{3})*)\s*G(?![a-zA-Z])/i);
    if(mg){ out.games = toNum(mg[1]); pushLog(`総G: 行内から ${out.games}`); }
  }
  if(!out.games){
    const cands = lines.map(ln=>{ const m=RE_G_ONLY.exec(ln); return m?toNum(m[1]):null; }).filter(v=>v!=null);
    if(cands.length){ out.games = Math.max(...cands); pushLog(`総G: G-only最大を採用 → ${out.games}`); }
  }

  // 文書全体ペア収集 → 期待分母でフィルタ＆最短距離
  const pairs = collectAllPairs(lines);

  // 風鈴・チェリー・氷 合算を選ぶ
  out.bell   = pickPairForMetric(pairs, "bell",   out.games);
  out.cherry = pickPairForMetric(pairs, "cherry", out.games);
  out.ice    = pickPairForMetric(pairs, "ice",    out.games);

  // もし分母しか取れず回数未取得＆総Gがあるなら、回数推定も可（ただし今回は誤紐付け防止のため保守的に不採用）
  return out;
}

/* ========== 推測（誤差→正規化） ========== */
function estimateAllSettings(m){
  const g = toNum(m.games)||0; if(!g) return [];
  const perG = {};
  ["bell","cherry","ice"].forEach(k=>{
    const v = toNum(m[k]);
    if(Number.isFinite(v)) perG[k]= v/g;
  });

  const rows=[1,2,5,6].map((s,i)=>{
    let err=0, used=0;
    if(perG.bell  !=null){ err+=Math.pow(perG.bell  - EXPECT.bell[i] ,2); used++; }
    if(perG.cherry!=null){ err+=Math.pow(perG.cherry- EXPECT.cherry[i],2); used++; }
    if(perG.ice   !=null){ err+=Math.pow(perG.ice   - EXPECT.ice[i]   ,2); used++; }
    const score = used? 1/(1+err) : 0;
    return {setting:s,score,percent:0};
  });

  const sum = rows.reduce((a,b)=>a+b.score,0);
  if(sum<=0) return rows.map(r=>({...r,percent:0}));
  return rows.map(r=>({...r,percent:r.score/sum*100}));
}

/* ========== UI ========== */
function barColor(p,max,min){
  if(max===min) return "rgba(96,165,250,0.85)";
  if(p===max) return "rgba(239,68,68,0.85)";
  if(p===min) return "rgba(147,197,253,0.85)";
  const t=(p-min)/Math.max(1,(max-min));
  const r=Math.round(147+(59-147)*t), g=Math.round(197+(130-197)*t), b=Math.round(253+(246-253)*t);
  return `rgba(${r},${g},${b},0.9)`;
}
function renderMetrics(){
  const wrap=document.getElementById("metrics"); wrap.innerHTML="";
  const keys=["games","bell","cherry","ice"];
  const label={games:"総G", bell:"風鈴合算", cherry:"チェリー合算", ice:"氷合算"};
  keys.forEach(k=>{
    const row=document.createElement("label"); row.style.display="flex"; row.style.alignItems="center"; row.style.gap="8px";
    const keySpan=document.createElement("span"); keySpan.className="key"; keySpan.textContent=label[k]; row.appendChild(keySpan);
    const input=document.createElement("input"); input.type="number"; input.step="1";
    input.value = (state.metrics[k]??"");
    input.oninput=e=>{
      const v = e.target.value==="" ? undefined : toNum(e.target.value);
      state.metrics[k]=v;
      renderBars(); renderMetrics();
    };
    row.appendChild(input);
    const tail=document.createElement("span"); tail.className="perg";
    if(k!=="games" && toNum(state.metrics.games)){
      const per = (toNum(state.metrics[k])||0)/toNum(state.metrics.games);
      tail.textContent = Number.isFinite(per) ? "/G "+per.toFixed(4) : "";
    }else tail.textContent="";
    row.appendChild(tail);
    wrap.appendChild(row);
  });

  const ul = document.getElementById("log"); ul.innerHTML = "";
  state.log.slice(-14).forEach(msg=>{
    const li=document.createElement("li"); li.textContent=msg; ul.appendChild(li);
  });
}
function renderBars(){
  const mount=document.getElementById("bars");
  const rows=estimateAllSettings(state.metrics);
  if(!rows.length){ mount.textContent="必要な数値が揃うと比較グラフが表示されます。"; return; }
  const perc=rows.map(r=>r.percent), max=Math.max(...perc), min=Math.min(...perc);
  mount.innerHTML="";
  rows.forEach(r=>{
    const head=document.createElement("div"); head.className="rowline";
    head.innerHTML=`<span>新ハナビ｜設定${r.setting}</span><span>${r.percent.toFixed(2)}%</span>`;
    const barWrap=document.createElement("div"); barWrap.className="bar-wrap";
    const bar=document.createElement("div"); bar.className="bar";
    const width = Math.max(0, Math.min(100, isFinite(r.percent)? r.percent : 0));
    bar.style.width = width + "%";
    bar.style.background = barColor(r.percent,max,min);
    barWrap.appendChild(bar);
    mount.appendChild(head); mount.appendChild(barWrap);
  });
}
function setError(msg){ const e=document.getElementById("err"); e.style.display=msg?"block":"none"; e.textContent=msg||""; }

/* ========== init ========== */
function init(){
  renderMetrics(); renderBars();
  document.getElementById("btn-parse").addEventListener("click", ()=>{
    setError("");
    const text=document.getElementById("text").value||"";
    state.metrics = parseMetricsFromText(text);

    if(!toNum(state.metrics.games)){
      setError("総G（例: 6,056G）が見つかりませんでした。");
    }else{
      const got=["bell","cherry","ice"].filter(k=>toNum(state.metrics[k])!=null);
      if(got.length===0) setError("『風鈴合算／チェリー合算／氷合算』が見つかりませんでした。");
    }
    renderMetrics(); renderBars();
  });

  // 自己テスト（あなたの提供テキスト断片で検証）
  try{
    const sample = `
新ハナビ
総プレイ数
風鈴合算
氷合算
チェリー合算
6,056G
813回
1/7.4
103回
1/58.8
381回
1/15.9
`;
    const m=parseMetricsFromText(sample);
    console.assert(m.games===6056 && m.bell===813 && m.ice===103 && m.cherry===381, "parse ok");
  }catch(_){}
}
init();
</script>
</body>
</html>
