<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>特リプTV｜新ハナビ 専用（最終調整版：2025.10.11）</title>
<style>
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;margin:24px;color:#111}
  h1{font-size:20px;margin:0 0 12px}
  .hint{background:#fff7ed;border:1px solid #fed7aa;color:#7c2d12;padding:8px 10px;border-radius:8px;font-size:13px}
  .error{background:#fef2f2;border:1px solid #fecaca;color:#991b1b;padding:8px 10px;border-radius:8px;font-size:13px;margin-top:8px;display:none}
  .card{background:#f9fafb;border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin-top:12px}
  .card h3{margin:0 0 8px;font-size:14px}
  textarea{width:100%;height:200px;border:1px solid #e5e7eb;border-radius:8px;padding:8px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:8px}
  @media(min-width:720px){.grid{grid-template-columns:1fr 1fr}}
  label span.key{width:150px;color:#374151;display:inline-block}
  input[type="number"]{border:1px solid #e5e7eb;border-radius:6px;padding:6px 8px;width:100%}
  .perg{font-size:11px;color:#6b7280;width:100px;text-align:right}
  .bar-wrap{width:100%;height:16px;background:#e5e7eb;border-radius:999px;overflow:hidden}
  .bar{height:16px;transition:width .3s ease}
  .rowline{display:flex;align-items:center;justify-content:space-between;font-size:12px;margin-bottom:4px}
  ul.log{margin:6px 0 0 18px;padding:0;font-size:12px;line-height:1.4}
  .opts{display:flex;gap:14px;align-items:center;font-size:13px;color:#374151;flex-wrap:wrap;margin-top:4px}
  .opts label{margin-right:8px;}
  .muted{color:#6b7280}
  .kv{display:flex;align-items:center;gap:8px}
  .secnote{font-size:12px;color:#6b7280;margin-top:4px}
  .pill{display:inline-block;background:#eef2ff;color:#3730a3;border-radius:999px;padding:2px 8px;font-size:11px}
  .two-col{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:1000px){.two-col{grid-template-columns:1fr 1fr}}
  .subgrid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  table{width:100%;border-collapse:collapse;font-size:12px}
  th,td{border:1px solid #e5e7eb;padding:6px 8px;text-align:left;vertical-align:top}
  th{background:#f3f4f6}
  .tag{display:inline-block;font-size:10px;padding:2px 6px;border-radius:6px;background:#f1f5f9;color:#0f172a;margin-left:6px}
</style>
</head>
<body>
<h1>特リプTV｜新ハナビ 専用（最終調整版：2025.10.11）</h1>

<div class="card">
  <h3>機種選択</h3>
  <select id="machine-select">
    <option value="SHIN_HANABI">新ハナビ 専用</option>
    </select>
</div>

<div class="hint">
  OCR崩れに強い抽出＋<b>BBレア役の重み調整</b>で結果の偏りを抑制。<br>
  **RB中ハズレ**の回数は、ユニメモで確認し、**編集モード**で手動入力してください。
  <small class="muted">※「未検出」は該当ラベルの近傍に有効な数値が見つからなかったことを示します。</small>
</div>

<div id="err" class="error"></div>

<div class="card">
  <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
    <h3>テキスト（手動貼り付け）</h3>
    <div class="opts">
      <label class="kv"><input id="edit-mode" type="checkbox"> 編集モード</label>
      <label class="kv"><input id="peace" type="checkbox"> ピースマーク出現</label>
      <label class="kv"><input id="yohaku-hazure" type="checkbox"> 予告音氷ハズレ（設定5・6確定）</label>
      <button id="btn-parse" class="btn" style="background:#2563eb;color:#fff;border:none;border-radius:8px;padding:6px 10px;">テキストから解析</button>
    </div>
  </div>
  <textarea id="text" placeholder="総プレイ数：6,056G
風鈴合算：813回 1/7.4
チェリー合算：393回 1/15.4
氷合算：103回 1/58.8"></textarea>
  <div class="secnote">※OCRで <code>チェリー⏎合算</code> / <code>花火チャレンジ中⏎はずれ</code> / <code>総プレイ数⏎6,056G</code> などの行割れは自動結合します。</div>
</div>

<div class="two-col">
  <div class="card">
    <h3>抽出メトリクス（編集可 / 編集モードOFFで固定）</h3>
    <div class="grid" id="metrics"></div>
  </div>

  <div class="card">
    <h3>抽出シグナル（読み取り専用）</h3>
    <div class="subgrid">
      <div><span class="key">BB斜め風鈴</span><span id="sig-bb-slant" class="pill muted">未検出</span></div>
      <div><span class="key">BBレア役(バラケ目)</span><span id="sig-bb-rare" class="pill muted">未検出</span></div>
      <div><span class="key">HCはずれ</span><span id="sig-rt-hc" class="pill muted">未検出</span></div>
      <div><span class="key">HGはずれ</span><span id="sig-rt-hg" class="pill muted">未検出</span></div>
      <div style="grid-column: 1 / 3;"><span class="key">RB中ハズレ（回）</span><span id="sig-rb-miss" class="pill muted">未検出（手動で回数を入力してください）</span></div>
      <div style="grid-column: 1 / 3;"><span class="key">予告音氷（ハズレ）</span><span id="sig-yohaku-hazure" class="pill muted">未検出</span></div>
    </div>
  </div>
</div>

<div class="card">
  <h3>抽出一覧（全項目）<span class="tag">読み取り専用</span></h3>
  <table id="table-all">
    <thead><tr><th>項目</th><th>回数</th><th>分母</th><th>備考</th></tr></thead>
    <tbody></tbody>
  </table>
</div>

<div class="card">
  <h3>推測比較（最大=赤、最小=水色／同値は中間色）</h3>
  <div id="bars">必要な数値が揃うと比較グラフが表示されます。</div>
</div>

<div class="card">
  <h3>抽出ログ</h3>
  <ul id="log" class="log"></ul>
</div>

<script>
/* === 機種別データ定義 === */
const MACHINE_DATA = {
  "SHIN_HANABI": {
    displayName: "新ハナビ 専用",
    // 期待値 (/G) — 設定: 1,2,5,6
    EXPECT: {
      bell:  [1/7.7,  1/7.6,  1/7.5,  1/7.3],
      cherry:[1/16.4, 1/15.3, 1/16.1, 1/15.6],
      ice:   [1/51.2, 1/51.8, 1/48.2, 1/49.3],
    },
    // 分母レンジ
    RANGE: {
      bell:   [4.5, 10.5], cherry: [10, 25], ice: [35, 80],
      bb_slant:[7,  13], bb_rare: [400, 30000], rt_hc: [4.6, 6.6], rt_hg: [8.5, 14.5],
      bellA:[10,30], bellB:[10,30], iceA:[35,90], iceB:[300,5000],
      chA1:[80,140], chA2:[15,30], chB:[150,450], total_any:[2,5000],
      oneMedal:[8,25], yohakuIce:[10,40], bbFlat:[1.0,2.0],
    },
    // 設定別期待分母
    EXPECT_DENOM: {
      bb_slant: {1:11.0, 2:9.0, 5:11.0, 6:9.0},
      bb_rare:  {1:16384,2:16384,5:16384,6:655.4},
      rt_hc_miss:{1:6.0,  2:5.8,  5:5.3,  6:5.1},
      rt_hg_miss:{1:13.4, 2:12.4, 5:10.1, 6:9.5}
    },
    // 【再調整】BBレア役の重みを0.2に大幅に下げ、他の小役の尤度が優先されるように調整
    WEIGHTS: { bell:1.0, cherry:1.0, ice:0.7, bb_slant:1.1, bb_rare:0.2, rt_hc_miss:1.0, rt_hg_miss:1.0, rb_miss:1.6 },
    // 設定リスト
    SETTINGS: [1, 2, 5, 6],
    // 備考
    NOTES: {
      "レア役（バラケ目/BB中）": "BB中のベルの崩れ目",
      "1枚役": "RB中の1枚役",
      "予告音氷": "RB中の1枚役告知で氷揃い",
      "予告音氷（ハズレ）": "RB中の1枚役告知でハズレ目（設定5・6確定）"
    }
  }
};

let currentMachine = MACHINE_DATA.SHIN_HANABI;

const state = {
  metrics:{games:undefined,bell:undefined,cherry:undefined,ice:undefined,rb_miss_count:undefined}, 
  extra:{bb_slant_den:null, bb_rare_den:null, rt_hc_den:null, rt_hg_den:null},
  flags:{peace:false, edit:false, yohakuHazure:false},
  allItems:[],
  log:[]
};

/* ---------- Utils ---------- */
const $ = (id)=>document.getElementById(id);
function toNum(x){ if(x==null) return undefined; const n=Number(String(x).replace(/,/g,'')); return Number.isFinite(n)?n:undefined; }
function pushLog(msg){ state.log.push(msg); }
function setError(msg){ const e=$("err"); e.style.display=msg?"block":"none"; e.textContent=msg||""; }
function setText(id, s){ const el=$(id); el.textContent=s; el.classList.toggle("muted", s.includes("未検出") || s==="—"); }

/* サニタイズ */
function sanitize(s){
  return (s||"")
    .replace(/[０-９]/g, d=>String.fromCharCode(d.charCodeAt(0)-0xFEE0))
    .replace(/[，]/g, ",").replace(/[．]/g, ".")
    .replace(/[：:]\s*/g, ": ")
    .replace(/[　]/g, " ")
    .replace(/[／]/g, "/")
    .replace(/\s+\/\s+/g, "/")
    .replace(/\s{2,}/g, " ")
    .trim();
}

/* ===== 行連結（OCRの見出し割れ修正） ===== */
function coalesceLines(lines){
  const out=[];
  for(let i=0;i<lines.length;i++){
    let cur=lines[i];
    // 総プレイ数/G 連結
    if(/^(総プレイ数|総回転数|プレイG|総ゲーム数)\s*$/.test(cur) && i+1<lines.length && /^[0-9,]+\s*G\s*$/i.test(lines[i+1])){
        out.push(lines[i+1]); i++; continue; 
    }
    // 小役 合算 連結
    if(/^(風鈴|チェリー|氷|チエリ)\s*$/.test(cur) && i+1<lines.length && /^(合算|合計|全)\s*$/.test(lines[i+1])){
      out.push(RegExp.$1 + "合算"); i++; continue;
    }
    // 花火チャレンジ/GAME中 はずれ 連結
    if(/^花火チャレンジ中\s*$/.test(cur) && i+1<lines.length && /^(?:はずれ|ハズレ|ハズレ目|はずい|歳机)\s*$/.test(lines[i+1])){
      out.push("花火チャレンジ中はずれ"); i++; continue;
    }
    if(/^花火GAME中\s*$/.test(cur) && i+1<lines.length && /^(?:はずれ|ハズレ|ハズレ目|はずい|歳机)\s*$/.test(lines[i+1])){
      out.push("花火GAME中はずれ"); i++; continue;
    }
    // レア役（バラケ目）連結
    if(/^レア役\s*$/.test(cur) && i+1<lines.length && /[()（].*バラケ目.*[)）]\s*$/.test(lines[i+1])){
      out.push("レア役（バラケ目）"); i++; continue;
    }
    out.push(cur);
  }
  return out;
}

/* パターン */
const RE_G_ONLY   = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*G\s*$/i;
const RE_KAI_LIKE = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*(?:回|囘|问|n|曰|日)?\s*$/i; // OCR誤認識対応
// 【重要修正】スラッシュ/縦棒/バックスラッシュの誤認識対応
const RE_FRAC_ANY = /[1Iｌl]\s*[\/\\।]\s*([0-9][0-9,]*(?:\.[0-9]+)?)/; 

function countFrac(line){
  const c=line.match(RE_KAI_LIKE);
  const f=line.match(RE_FRAC_ANY);
  const denom=f?parseFloat(f[1].replace(/,/g,'')):undefined;
  return { count:c?toNum(c[1]):undefined, denom };
}

/* 文書全体の「回+1/◯」候補 */
function collectAllPairs(lines){
  const pairs=[];
  for(let i=0;i<lines.length;i++){
    const {count,denom}=countFrac(lines[i]);
    if(count!=null && denom!=null){ pairs.push({idx:i,count,denom}); continue; }
    const c=lines[i].match(RE_KAI_LIKE);
    const f=(i+1<lines.length)?lines[i+1].match(RE_FRAC_ANY):null;
    // 回数のみの行の次に 1/◯ が来るパターン
    if(c && f){ pairs.push({idx:i,count:toNum(c[1]),denom:parseFloat(f[1].replace(/,/g,''))}); i++; }
  }
  pushLog(`pairs: ${pairs.length}件収集`);
  return pairs;
}

/* 近傍探索（±20行） */
function pickNearBy(lines, labelIdx, window, range){
  if(labelIdx<0) return null;
  const [lo,hi]=range;
  let best=null, bestDist=1e9;
  for(let j=Math.max(0,labelIdx-window); j<Math.min(lines.length,labelIdx+window+1); j++){
    const {count,denom}=countFrac(lines[j]);
    // 1行に「回」と「1/◯」があるパターン
    if(count!=null && Number.isFinite(denom) && denom>=lo && denom<=hi){
      const dist=Math.abs(j-labelIdx);
      if(dist<bestDist){ best={count,denom,idx:j}; bestDist=dist; }
    }else{
      const c=lines[j].match(RE_KAI_LIKE);
      const f=(j+1<lines.length)?lines[j+1].match(RE_FRAC_ANY):null;
      // 「回」と「1/◯」が2行に分かれているパターン
      if(c && f){
        const cnt=toNum(c[1]); const den=parseFloat(f[1].replace(/,/g,''));
        if(cnt!=null && Number.isFinite(den) && den>=lo && den<=hi){
          const dist=Math.abs(j-labelIdx);
          if(dist<bestDist){ best={count:cnt,denom:den,idx:j}; bestDist=dist; }
        }
      }
    }
  }
  return best;
}

/* ラベル→近傍→全体フォールバック */
function resolveMetric(lines, labelRegex, range, labelName, globalPairs){
  const idx=lines.findIndex(l=>labelRegex.test(l));
  let got=pickNearBy(lines, idx, 20, range);
  
  // 【重要修正】小役3種以外は全体フォールバックロジックを無効化し、ボーナス回数の誤認識を防ぐ
  if(!got && ["bell", "cherry", "ice"].includes(labelName)){
    const [lo,hi]=range;
    const expects = currentMachine.EXPECT[labelName]?.map(v=>1/v) ?? [];
    let best=null, bestScore=Infinity;
    for(const p of globalPairs){
      if(p.denom<lo || p.denom>hi) continue;
      const d = expects.length? Math.min(...expects.map(ex=>Math.abs(ex - p.denom))) : 0;
      // 期待値からのズレ + 元の行からの距離
      const score = d + 0.0001*Math.abs((idx>=0?idx:p.idx)-p.idx);
      if(score<bestScore){ best=p; bestScore=score; }
    }
    got=best||null;
    if(got) pushLog(`${labelName||'項目'}: fallback採用 idx=${got.idx} → ${got.count??'-'}回 (1/${got.denom??'-'})`);
  }else if(got){
    pushLog(`${labelName||'項目'}: 近傍採用 idx=${got.idx} → ${got.count??'-'}回 (1/${got.denom??'-'})`);
  }
  return got;
}

/* === 解析本体 === */
function parseMetricsFromText(raw){
  state.log = [];
  state.allItems = [];
  const t = sanitize(raw);
  const rawLines = t.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const lines = coalesceLines(rawLines);

  const out = {games:undefined,bell:undefined,cherry:undefined,ice:undefined,rb_miss_count:undefined}; 
  const extra = {bb_slant_den:null, bb_rare_den:null, rt_hc_den:null, rt_hg_den:null};

  // 総G：G-only最大
  const cands = lines.map(ln=>{ const m=RE_G_ONLY.exec(ln); return m?toNum(m[1]):null; }).filter(v=>v!=null);
  if(cands.length){ out.games = Math.max(...cands); pushLog(`総G: G-only最大 → ${out.games}`); } else pushLog("総G: 見つからず");

  const allPairs = collectAllPairs(lines);

  // 合算3種 (OCR誤認識パターン追加)
  const bell   = resolveMetric(lines, /風鈴\s*(?:合算|合計|全)/, currentMachine.RANGE.bell,   "bell",   allPairs);
  const cherry = resolveMetric(lines, /チェリー\s*(?:合算|合計|全|チエリ)/, currentMachine.RANGE.cherry, "cherry", allPairs);
  const ice    = resolveMetric(lines, /氷\s*(?:合算|合計|全)/,    currentMachine.RANGE.ice,    "ice",    allPairs);

  if(bell){ out.bell=bell.count; addItem("風鈴合算", bell.count, bell.denom); }
  if(cherry){ out.cherry=cherry.count; addItem("チェリー合算", cherry.count, cherry.denom); }
  if(ice){ out.ice=ice.count; addItem("氷合算", ice.count, ice.denom); }

  // 追加シグナル（近傍）
  const bbSlant = pickNearBy(lines, lines.findIndex(l=>/(風斜め揃い|斜め風鈴|風鈴B|風斜め揃|風鈴斜め揃)/.test(l)), 20, currentMachine.RANGE.bb_slant);
  if(bbSlant){ extra.bb_slant_den = bbSlant.denom; addItem("風斜め揃い（BB中）", bbSlant.count, bbSlant.denom); }
  const bbFlat = pickNearBy(lines, lines.findIndex(l=>/(風鈴中段揃)/.test(l)), 20, currentMachine.RANGE.bbFlat);
  if(bbFlat){ addItem("風鈴中段揃（BB中）", bbFlat.count, bbFlat.denom); }
  const bbRare = pickNearBy(lines, lines.findIndex(l=>/(レア役|バラケ目|レア)/.test(l)), 20, currentMachine.RANGE.bb_rare);
  if(bbRare){ extra.bb_rare_den = bbRare.denom; addItem("レア役（バラケ目/BB中）", bbRare.count, bbRare.denom); }
  const rtHC = pickNearBy(lines, lines.findIndex(l=>/花火チャレンジ中はずれ/.test(l)), 20, currentMachine.RANGE.rt_hc);
  if(rtHC){ extra.rt_hc_den = rtHC.denom; addItem("花火チャレンジ中はずれ", rtHC.count, rtHC.denom); }
  const rtHG = pickNearBy(lines, lines.findIndex(l=>/花火GAME中はずれ/.test(l)), 20, currentMachine.RANGE.rt_hg);
  if(rtHG){ extra.rt_hg_den = rtHG.denom; addItem("花火GAME中はずれ", rtHG.count, rtHG.denom); }

  // RB中ハズレ: 自動抽出ロジックは削除済（手動入力に依存）
  // out.rb_miss_count は undefined のまま。手動入力は renderMetrics で処理される。
  
  // 内訳（A/B等） - これらの項目は fallback を使わない
  addByLabelNear(lines, /風鈴A/, "風鈴A", currentMachine.RANGE.bellA);
  addByLabelNear(lines, /風鈴B/, "風鈴B", currentMachine.RANGE.bellB);
  addByLabelNear(lines, /氷A/,   "氷A",   currentMachine.RANGE.iceA);
  addByLabelNear(lines, /氷B/,   "氷B",   currentMachine.RANGE.iceB);
  addByLabelNear(lines, /チェリーA1/, "チェリーA1", currentMachine.RANGE.chA1);
  addByLabelNear(lines, /チェリーA2/, "チェリーA2", currentMachine.RANGE.chA2);
  addByLabelNear(lines, /チェリーB/,  "チェリーB",  currentMachine.RANGE.chB);

  // 総ボーナス系 - これらの項目は fallback を使わない
  addByLabelNear(lines, /総ボーナス|総术一十ㄡ|総ボ一十ス/, "総ボーナス", currentMachine.RANGE.total_any);
  addByLabelNear(lines, /総BB|合計BB|BB合計|綌BB|FyBB/, "総BB", currentMachine.RANGE.total_any);
  addByLabelNear(lines, /ドンBB|FyBB/, "ドンBB", currentMachine.RANGE.total_any);
  addByLabelNear(lines, /赤七BB|赤７BB/, "赤七BB", currentMachine.RANGE.total_any);
  addByLabelNear(lines, /RB\b|REG\b|レギュラーボーナス|R B/, "RB", currentMachine.RANGE.total_any);

  // 1枚役／予告音氷 - これらの項目は fallback を使わない
  addByLabelNear(lines, /1枚役/, "1枚役", currentMachine.RANGE.oneMedal);
  addByLabelNear(lines, /予告音氷/, "予告音氷", currentMachine.RANGE.yohakuIce);

  // フラグ（予告音氷ハズレ）を一覧にも明示
  if(state.flags.yohakuHazure){
    addItem("予告音氷（ハズレ）", null, null);
  }

  // RB中ハズレの項目を全アイテムリストに追加（手動入力項目なので、値はstateから）
  const rbMissCount = toNum(state.metrics.rb_miss_count);
  addItem("RB中ハズレ", rbMissCount, null);


  state.extra = extra;
  updateSignals(extra);
  pushLog(`summary: bell=${out.bell??"-"} | cherry=${out.cherry??"-"} | ice=${out.ice??"-"} | bb_slant=1/${extra.bb_slant_den??"-"} | bb_rare=1/${extra.bb_rare_den??"-"} | hc=1/${extra.rt_hc_den??"-"} | hg=1/${extra.rt_hg_den??"-"} | rb_miss=${state.metrics.rb_miss_count??"-"}`);
  renderAllTable();
  
  return {games:out.games, bell:out.bell, cherry:out.cherry, ice:out.ice};

  function addItem(name, count, denom){
    state.allItems.push({name, count: (Number.isFinite(count)? count : null), denom: (Number.isFinite(denom)? denom : null)});
  }
  function addByLabelNear(lines, labelRe, labelName, range){
    // fallbackを使わず、近傍探索のみを実行
    const idx=lines.findIndex(l=>labelRe.test(l));
    const got = pickNearBy(lines, idx, 20, range);
    if(got) addItem(labelName, got.count, got.denom);
  }
}

/* ---------- 推測（尤度ベース：二項ログ尤度 + 追加指標のガウス罰則） ---------- */
function estimateAllSettings(m){
  const g = toNum(m.games)||0; if(!g) return [];
  const EPS=1e-9, clamp01=(p)=>Math.min(1-EPS,Math.max(EPS,p));
  const ll_binom=(k,n,p)=>{p=clamp01(p); const q=1-p; return k*Math.log(p)+(n-k)*Math.log(q);};
  const penalty_denom=(d,exp,w)=>(!Number.isFinite(d)||!Number.isFinite(exp))?0:(-w*Math.pow((d-exp)/exp,2)/(2*Math.pow(0.12,2)));

  const have={bell:Number.isFinite(toNum(m.bell)),cherry:Number.isFinite(toNum(m.cherry)),ice:Number.isFinite(toNum(m.ice))};
  const settings=currentMachine.SETTINGS;
  const rows=settings.map((s,i)=>{
    let ll=0, used=0;
    // 共通小役
    if(have.bell){ ll+=currentMachine.WEIGHTS.bell*ll_binom(toNum(m.bell), g, currentMachine.EXPECT.bell[i]); used++; }
    if(have.cherry){ ll+=currentMachine.WEIGHTS.cherry*ll_binom(toNum(m.cherry), g, currentMachine.EXPECT.cherry[i]); used++; }
    if(have.ice){ ll+=currentMachine.WEIGHTS.ice*ll_binom(toNum(m.ice), g, currentMachine.EXPECT.ice[i]); used++; }
    
    // 追加指標 (分母ベース)
    if(state.extra.bb_slant_den){ ll+=penalty_denom(state.extra.bb_slant_den, currentMachine.EXPECT_DENOM.bb_slant[s], currentMachine.WEIGHTS.bb_slant); used++; }
    // 【再調整】BBレア役の重みを大幅に下げ、設定6への過度な偏りを防ぐ
    if(state.extra.bb_rare_den){ ll+=penalty_denom(state.extra.bb_rare_den, currentMachine.EXPECT_DENOM.bb_rare[s], currentMachine.WEIGHTS.bb_rare); used++; }
    if(state.extra.rt_hc_den){ ll+=penalty_denom(state.extra.rt_hc_den, currentMachine.EXPECT_DENOM.rt_hc_miss[s], currentMachine.WEIGHTS.rt_hc_miss); used++; }
    if(state.extra.rt_hg_den){ ll+=penalty_denom(state.extra.rt_hg_den, currentMachine.EXPECT_DENOM.rt_hg_miss[s], currentMachine.WEIGHTS.rt_hg_miss); used++; }
    
    // RB中ハズレ (手動入力の値を使用)
    if(Number.isFinite(toNum(m.rb_miss_count))){
      const miss=toNum(m.rb_miss_count);
      // RB中ハズレが0回の場合、設定5,6にボーナス
      if(miss===0){ 
        if(s===5||s===6){ ll += currentMachine.WEIGHTS.rb_miss*1.5; used++; }
      }
      // RB中ハズレが1回以上の場合、設定1,2に罰則
      else if(miss>0){ 
        if(s===1||s===2){ ll -= currentMachine.WEIGHTS.rb_miss*(1+miss); used++; }
        if(s===5||s===6){ ll += currentMachine.WEIGHTS.rb_miss*Math.min(1,miss*0.2); used++; }
      }
    }
    
    // 追加制約 (フラグ)
    if(s===1 && state.flags.peace){ ll = -Infinity; used++; }           // ピース → 設定1禁止
    if((s===1||s===2) && state.flags.yohakuHazure){ ll = -Infinity; used++; } // 予告音氷ハズレ → 1・2禁止
    
    return {setting:s, ll: used? ll : -Infinity};
  });

  const maxLL=Math.max(...rows.map(r=>r.ll));
  const expS=rows.map(r=>Math.exp(r.ll-maxLL));
  const sumS=expS.reduce((a,b)=>a+b,0)||1;
  return rows.map((r,i)=>({setting:r.setting, score:expS[i], percent:(expS[i]/sumS)*100}));
}

/* ---------- UI ---------- */
function barColor(p,max,min){
  if(max===min) return "rgba(96,165,250,0.85)";
  if(p===max) return "rgba(239,68,68,0.85)";
  if(p===min) return "rgba(147,197,253,0.85)";
  const t=(p-min)/Math.max(1,(max-min));
  const r=Math.round(147+(59-147)*t), g=Math.round(197+(130-197)*t), b=Math.round(253+(246-253)*t);
  return `rgba(${r},${g},${b},0.9)`;
}
function renderBars(){
  const mount=$("bars");
  const rows=estimateAllSettings(state.metrics);
  if(!rows.length){ mount.textContent="必要な数値が揃うと比較グラフが表示されます。"; return; }
  const perc=rows.map(r=>r.percent), max=Math.max(...perc), min=Math.min(...perc);
  mount.innerHTML="";
  rows.forEach(r=>{
    const head=document.createElement("div"); head.className="rowline";
    head.innerHTML=`<span>${currentMachine.displayName}｜設定${r.setting}</span><span>${r.percent.toFixed(2)}%</span>`;
    const barWrap=document.createElement("div"); barWrap.className="bar-wrap";
    const bar=document.createElement("div"); bar.className="bar";
    bar.style.width = Math.max(0, Math.min(100, isFinite(r.percent)? r.percent : 0)) + "%";
    bar.style.background = barColor(r.percent,max,min);
    barWrap.appendChild(bar);
    mount.appendChild(head); mount.appendChild(barWrap);
  });
}
function updateSignals(ex){
  setText("sig-bb-slant", ex.bb_slant_den? `1/${ex.bb_slant_den}` : "未検出");
  setText("sig-bb-rare",  ex.bb_rare_den ? `1/${ex.bb_rare_den}`  : "未検出");
  setText("sig-rt-hc",    ex.rt_hc_den   ? `1/${ex.rt_hc_den}`    : "未検出");
  setText("sig-rt-hg",    ex.rt_hg_den   ? `1/${ex.rt_hg_den}`    : "未検出");
  const rbMissCount = toNum(state.metrics.rb_miss_count);
  setText("sig-rb-miss",  Number.isFinite(rbMissCount)? `${rbMissCount}回 (手動入力)` : "未検出（手動で回数を入力してください）");
  setText("sig-yohaku-hazure", state.flags.yohakuHazure? "チェックON（設定1・2=0%）" : "未検出");
}

const METRIC_KEYS=["games","bell","cherry","ice","rb_miss_count"];
const METRIC_LABEL={games:"総G", bell:"風鈴合算（回）", cherry:"チェリー合算（回）", ice:"氷合算（回）", rb_miss_count:"RB中ハズレ（回）"};
function renderMetrics(firstRender=false){
  const wrap=$("metrics");
  if(firstRender){
    wrap.innerHTML="";
    METRIC_KEYS.forEach(k=>{
      const row=document.createElement("label"); row.style.display="flex"; row.style.alignItems="center"; row.style.gap="8px";
      const keySpan=document.createElement("span"); keySpan.className="key"; keySpan.textContent=METRIC_LABEL[k]; row.appendChild(keySpan);
      const input=document.createElement("input"); input.type="number"; input.step="1"; input.id=`inp-${k}`;
      input.value = state.metrics[k]??"";
      input.oninput=(e)=>{
        if(!state.flags.edit) return;
        const v = e.target.value==="" ? undefined : toNum(e.target.value);
        state.metrics[k]=v;
        renderBars();
        updatePerG(k);
        // RB中ハズレの入力が変更されたらシグナルも更新
        if(k === "rb_miss_count") updateSignals(state.extra);
      };
      input.onblur=()=>{ renderMetrics(false); };
      row.appendChild(input);
      const tail=document.createElement("span"); tail.className="perg"; tail.id=`perg-${k}`; row.appendChild(tail);
      wrap.appendChild(row);
    });
  }
  METRIC_KEYS.forEach(k=>{
    const input=$(`inp-${k}`);
    if(document.activeElement!==input){ input.value = state.metrics[k]??""; }
    input.disabled = !state.flags.edit;
    updatePerG(k);
  });

  const ul = $("log"); ul.innerHTML = "";
  state.log.slice(-30).forEach(msg=>{ const li=document.createElement("li"); li.textContent=msg; ul.appendChild(li); });
}
function updatePerG(k){
  const span=$(`perg-${k}`);
  if(k!=="games" && k!=="rb_miss_count" && toNum(state.metrics.games)){
    const per=(toNum(state.metrics[k])||0)/toNum(state.metrics.games);
    span.textContent = Number.isFinite(per) ? "/G "+per.toFixed(4) : "";
  }else span.textContent="";
}

function renderAllTable(){
  const tb = $("table-all").querySelector("tbody");
  tb.innerHTML = "";
  const rows = state.allItems.filter(r => r.name !== "RB中ハズレ");
  
  // RB中ハズレは手動入力項目なので、リストの先頭に表示する
  const rbMissRow = state.allItems.find(r => r.name === "RB中ハズレ");
  if(rbMissRow){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${rbMissRow.name}</td>
      <td>${Number.isFinite(rbMissRow.count)? rbMissRow.count : "—"}</td>
      <td>—</td>
      <td>手動入力項目</td>`;
    tb.appendChild(tr);
  }

  if(!rows.length && !rbMissRow){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="4" class="muted">抽出できた項目がありません。</td>`;
    tb.appendChild(tr);
    return;
  }
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const note = currentMachine.NOTES[r.name] || "";
    tr.innerHTML = `<td>${r.name}</td>
      <td>${Number.isFinite(r.count)? r.count : "—"}</td>
      <td>${Number.isFinite(r.denom)? "1/"+r.denom.toFixed(2) : "—"}</td>
      <td>${note||"—"}</td>`;
    tb.appendChild(tr);
  });
}

function loadMachine(machineKey) {
    currentMachine = MACHINE_DATA[machineKey];
    if (!currentMachine) {
        setError(`機種データが見つかりません: ${machineKey}`);
        return;
    }
    // 機種名/タイトル更新
    $("machine-select").value = machineKey;
    document.querySelector('h1').textContent = `特リプTV｜${currentMachine.displayName}（最終調整版：2025.10.11）`;
    
    // データをクリアして再描画
    state.metrics={games:undefined,bell:undefined,cherry:undefined,ice:undefined,rb_miss_count:undefined};
    state.extra={bb_slant_den:null, bb_rare_den:null, rt_hc_den:null, rt_hg_den:null};
    state.allItems=[];
    
    renderMetrics(true); // metrics UIを初期化
    renderAllTable();
    renderBars();
    updateSignals(state.extra);
}

/* ---------- init ---------- */
function init(){
  loadMachine("SHIN_HANABI"); // 初期機種ロード
  
  // 機種選択ハンドラ
  $("machine-select").addEventListener("change",(e)=>{
      loadMachine(e.target.value);
  });

  $("btn-parse").addEventListener("click", ()=>{
    try{
      setError("");
      // parseMetricsFromTextの結果をstate.metricsにマージ (rb_miss_countは手動入力を活かすため、そのまま残す)
      const parsedMetrics = parseMetricsFromText($("text").value||"");
      state.metrics.games = parsedMetrics.games;
      state.metrics.bell = parsedMetrics.bell;
      state.metrics.cherry = parsedMetrics.cherry;
      state.metrics.ice = parsedMetrics.ice;

      if(!toNum(state.metrics.games)){
        setError("総G（例: 6,056G）が見つかりませんでした。");
      }else{
        const got=["bell","cherry","ice"].filter(k=>toNum(state.metrics[k])!=null);
        if(got.length===0) setError("『風鈴合算／チェリー合算／氷合算』が見つかりませんでした。");
      }
      renderMetrics(false); renderBars();
    }catch(err){ setError("解析中にエラー: "+(err && err.message ? err.message : String(err))); }
  });

  $("edit-mode").addEventListener("change",(e)=>{ state.flags.edit = e.target.checked; renderMetrics(false); });
  $("peace").addEventListener("change",(e)=>{ state.flags.peace = e.target.checked; renderBars(); });
  $("yohaku-hazure").addEventListener("change",(e)=>{ state.flags.yohakuHazure = e.target.checked; updateSignals(state.extra); renderBars(); });

  // デモ用自己テスト（初期データ挿入）
  const sample = `新ハナビ
総プレイ数
小役
風鈴
合算
氷
合算
チェリー
合算
BB中詳細
風鈴中段揃
風斜め揃い
レア役
RT
花火チャレンジ中
はずれ
花火GAME中
はずれ
総ボーナス
総BB
ドンBB
赤七BB
RB
6,056G
46回
1/131.7
35回
1/173.0
16回
1/378.5
19回
1/318.7
11回
1/550.5
813回
1/7.4
103回
1/58.8
393回
1/15.4
910回
1/1.1
103回
1/9.8
1回
1/1,014.0
83回
1/6.1
42回
1/13.0
1枚役
8回
1/12.0
予告音氷
1/24.0
RB中詳細(天の他)
ハズレ
0回`;
  const parsedMetrics = parseMetricsFromText(sample);
  state.metrics.games = parsedMetrics.games;
  state.metrics.bell = parsedMetrics.bell;
  state.metrics.cherry = parsedMetrics.cherry;
  state.metrics.ice = parsedMetrics.ice;
  state.metrics.rb_miss_count = 0; // デモデータとして0回をセット

  renderMetrics(false); renderBars();
}
init();
</script>
</body>
</html>
