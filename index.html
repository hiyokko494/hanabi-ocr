<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ユニメモ解析｜新ハナビ（OCR / テキスト対応）</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", "Meiryo", sans-serif; margin: 24px; color: #111; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .hint { background: #fff7ed; border: 1px solid #fed7aa; color: #7c2d12; padding: 8px 10px; border-radius: 8px; font-size: 13px; }
    .error { background: #fef2f2; border: 1px solid #fecaca; color: #991b1b; padding: 8px 10px; border-radius: 8px; font-size: 13px; margin-top: 8px; display:none; }
    .row { display: flex; flex-wrap: wrap; align-items: center; gap: 8px; margin-top: 12px; }
    .btn { font-size: 13px; padding: 6px 10px; border-radius: 6px; border: 0; cursor: pointer; }
    .btn.primary { background: #111; color: #fff; }
    .btn.disabled { background: #d1d5db; color: #6b7280; cursor: not-allowed; }
    img.thumb { height: 112px; border: 1px solid #e5e7eb; border-radius: 8px; }
    .card { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 10px; padding: 12px; margin-top: 12px; }
    .card h3 { margin: 0 0 8px; font-size: 14px; }
    textarea { width: 100%; height: 140px; border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 8px; }
    @media (min-width: 640px) { .grid { grid-template-columns: 1fr 1fr; } }
    label span.key { width: 72px; color: #6b7280; display: inline-block; }
    input[type="number"] { border: 1px solid #e5e7eb; border-radius: 6px; padding: 6px 8px; width: 100%; }
    .perg { font-size: 11px; color: #6b7280; width: 80px; text-align: right; }
    .bar-wrap { width: 100%; height: 16px; background: #e5e7eb; border-radius: 999px; overflow: hidden; }
    .bar { height: 16px; transition: width 300ms ease; }
    .rowline { display: flex; align-items: center; justify-content: space-between; font-size: 12px; margin-bottom: 4px; }
    .footer { margin-top: 16px; font-size: 12px; color: #6b7280; }
    code { background: #f3f4f6; padding: 0 4px; border-radius: 4px; }
    .spinner { display:none; width: 14px; height: 14px; border: 2px solid #fff; border-right-color: transparent; border-radius: 50%; animation: spin 0.6s linear infinite; margin-left:6px; }
    @keyframes spin { to { transform: rotate(360deg);} }
  </style>
</head>
<body>
  <h1>ユニメモ解析｜新ハナビ（OCR / テキスト対応）</h1>

  <div class="hint">
    <strong>使い方:</strong> スクショを選んで「画像から解析」。失敗や未準備なら、下のテキスト欄に貼り付けて「テキストから解析」。<br/>
    iPhoneは画像を<strong>長押し → テキストをコピー</strong>でOK。貼り付けが「ラベル行 → 数値行」に分かれても自動で対応します。<br/>
    ローカルOCRを使う場合は <code>tesseract/</code> に必要ファイルを置いてから再読み込み。
  </div>

  <div id="err" class="error"></div>

  <div class="row">
    <input id="file" type="file" accept="image/*" />
    <img id="thumb" class="thumb" style="display:none" alt="preview"/>
    <button id="btn-ocr" class="btn primary disabled" disabled>
      画像から解析 <span id="spin" class="spinner"></span>
    </button>
  </div>

  <div class="card">
    <h3>抽出一覧（貼り付けテキストから拾えた項目）</h3>
    <div id="extracted">まだ抽出結果がありません。</div>
  </div>

  <div class="card">
    <div style="display:flex; align-items:center; justify-content:space-between;">
      <h3>テキスト（手動貼り付け）</h3>
      <button id="btn-parse" class="btn" style="background:#2563eb; color:#fff;">テキストから解析</button>
    </div>
    <textarea id="text" placeholder="例)
総プレイ数 6,056G
風鈴合算 813回 1/7.4
チェリー合算 381回 1/15.9
氷合算 103回 1/58.8"></textarea>
  </div>

  <div class="card">
    <h3>抽出メトリクス（編集可）</h3>
    <div class="grid" id="metrics"></div>
  </div>

  <div class="card">
    <h3>推測比較（最大=赤、最小=水色）</h3>
    <div id="bars">必要な数値が揃うと比較グラフが表示されます。</div>
  </div>

  <div class="footer">
    OCRをローカルで使う場合：<code>tesseract/</code> に <code>worker.min.js</code>、<code>tesseract-core.wasm.js</code>、<code>tesseract.min.js</code>、および <code>lang-data/jpn.traineddata.gz</code> と <code>lang-data/eng.traineddata.gz</code> を配置。
  </div>

<script>
/* ===== プリセット ===== */
const PRESETS = {
  "新ハナビ": {
    bell:   [1/7.7,  1/7.6,  1/7.5,  1/7.3],
    cherry: [1/16.4, 1/15.3, 1/16.1, 1/15.6],
    ice:    [1/51.2, 1/51.8, 1/48.2, 1/49.3],
  },
};

const state = {
  imgUrl: null,
  ocrText: "",
  metrics: { games: undefined, bell: undefined, cherry: undefined, ice: undefined },
};

/* ===== ユーティリティ ===== */
function sanitize(s) {
  return (s || "")
    .replace(/[０-９]/g, d => String.fromCharCode(d.charCodeAt(0) - 0xFEE0))
    .replace(/[，]/g, ",").replace(/[．]/g, ".").replace(/[　]/g, " ")
    .replace(/\r/g, "");
}

const NUM_G       = /^\s*([0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)\s*G\s*$/i;
const NUM_KAI     = /^\s*([0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)\s*回\s*$/;
const NUM_1DIV    = /^\s*1\s*\/\s*([0-9]+(?:\.[0-9]+)?)\s*$/;
const NUM_PERCENT = /^\s*[0-9]+(?:\.[0-9]+)?\s*%\s*$/;

/* ===== テキスト → メトリクス抽出 ===== */
function parseMetricsFromText(rawText) {
  let text = sanitize(rawText || "");
  // OCRノイズ救済: 45n → 45回
  text = text.replace(/(\b[0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)\s*[nN]\b/g, (_, num) => `${num}回`);

  const lines = text.split(/\n+/).map(l => l.trim()).filter(Boolean);

  // 同行インライン抽出（ラベルと値が同じ行にある場合）
  const getInline = (labelRe, unitReg, firstNumber = /([0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)/) => {
    const line = lines.find(l => labelRe.test(l) && unitReg.test(l));
    if (!line) return undefined;
    const m = line.match(firstNumber);
    return m ? Number(m[1].replace(/,/g, "")) : undefined;
  };

  let games  = getInline(/総[ププ]レイ|総ゲーム|総プレイ数|ゲーム数|回転数/i, /G/i);
  let bell   = getInline(/風鈴合算|風鈴\s*合算/i, /回/);
  let cherry = getInline(/チェリー合算|チェリー\s*合算/i, /回/);
  let ice    = getInline(/氷合算|氷\s*合算/i, /回/);

  // 一覧出力用
  const extras = []; // {label, unit, value}

  // ストリーミング割当：ラベル検出→次に出る値（単位一致なら優先）を紐付け
  const WANT = [
    { key: "games",  re: /総[ププ]レイ|総ゲーム|総プレイ数|ゲーム数|回転数/i, unit: "G"  , label:"総プレイ数" },
    { key: "bell",   re: /風鈴合算|風鈴\s*合算/i,                                   unit: "回" , label:"風鈴合算" },
    { key: "cherry", re: /チェリー合算|チェリー\s*合算/i,                           unit: "回" , label:"チェリー合算" },
    { key: "ice",    re: /氷合算|氷\s*合算/i,                                       unit: "回" , label:"氷合算" },
  ];

  const NUM_G2       = /^\s*([0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)\s*G\s*$/i;
  const NUM_KAI2     = /^\s*([0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)\s*回\s*$/;
  const NUM_RATIO    = /^\s*1\s*\/\s*[0-9]+(?:\.[0-9]+)?\s*$/;
  const NUM_PERCENT2 = /^\s*[0-9]+(?:\.[0-9]+)?\s*%\s*$/;
  const NUM_PLATES   = /^\s*[0-9,]+\s*枚\s*$/;

  const pending = []; // { key?, unit, label? }

  for (const line of lines) {
    let valueInfo = null;

    if (NUM_G2.test(line)) {
      const v = Number(line.replace(NUM_G2, "$1").replace(/,/g, ""));
      valueInfo = { unit: "G", value: v };
    } else if (NUM_KAI2.test(line)) {
      const v = Number(line.replace(NUM_KAI2, "$1").replace(/,/g, ""));
      valueInfo = { unit: "回", value: v };
    } else if (NUM_RATIO.test(line) || NUM_PERCENT2.test(line) || NUM_PLATES.test(line) || /^[0-9,.\-\/%]+$/.test(line)) {
      // 比率/％/枚/数値の塊はスキップ（必要なら拡張可）
    } else {
      // ラベル検出
      let matchedWant = false;
      for (const want of WANT) {
        if (want.re.test(line)) {
          pending.push({ key: want.key, unit: want.unit, label: want.label });
          matchedWant = true;
        }
      }
      if (!matchedWant) {
        // 汎用ラベル（次に来るG/回をひも付け）
        pending.push({ key: null, unit: null, label: line });
      }
    }

    if (valueInfo && pending.length) {
      // 先頭から、単位が指定されていれば一致優先、なければ素直に割当て
      let idx = -1;
      for (let i=0;i<pending.length;i++) {
        if (!pending[i].unit || pending[i].unit === valueInfo.unit) { idx = i; break; }
      }
      if (idx !== -1) {
        const p = pending.splice(idx,1)[0];
        if (p.key === "games"  && games  == null) games  = valueInfo.value;
        if (p.key === "bell"   && bell   == null) bell   = valueInfo.value;
        if (p.key === "cherry" && cherry == null) cherry = valueInfo.value;
        if (p.key === "ice"    && ice    == null) ice    = valueInfo.value;
        extras.push({ label: p.label || "（ラベル）", unit: valueInfo.unit, value: valueInfo.value });
      }
    }
  }

  return { games, bell, cherry, ice, extras };
}

/* ===== 推測ロジック（Poisson尤度） ===== */
function estimateAllSettings(metrics) {
  const g = metrics.games || 0;
  if (!g) return [];
  const obs = {
    bell:   metrics.bell   ?? 0,
    cherry: metrics.cherry ?? 0,
    ice:    metrics.ice    ?? 0,
  };
  const core = PRESETS["新ハナビ"];
  const base = [1,2,5,6];

  const use = {
    bell:   obs.bell   > 0,
    cherry: obs.cherry > 0,
    ice:    obs.ice    > 0,
  };

  const rows = base.map((setting, idx) => {
    let loglik = 0;
    if (use.bell)   { const denom = 1/core.bell[idx];   const lambda = g/denom;   loglik += obs.bell*Math.log(Math.max(lambda,1e-9)) - lambda; }
    if (use.cherry) { const denom = 1/core.cherry[idx]; const lambda = g/denom;   loglik += obs.cherry*Math.log(Math.max(lambda,1e-9)) - lambda; }
    if (use.ice)    { const denom = 1/core.ice[idx];    const lambda = g/denom;   loglik += obs.ice*Math.log(Math.max(lambda,1e-9)) - lambda; }
    return { setting, loglik };
  });

  const maxLL = Math.max(...rows.map(r=>r.loglik));
  const exps = rows.map(r => Math.exp(r.loglik - maxLL));
  const sum  = exps.reduce((a,b)=>a+b,0) || 1;
  return rows.map((r,i)=>({ setting:r.setting, percent: (exps[i]/sum)*100 }));
}

function barColor(p, maxP, minP) {
  if (p === maxP) return "rgba(239,68,68,0.85)";     // 赤
  if (p === minP) return "rgba(147,197,253,0.85)";   // 水色
  const t = (p - minP) / Math.max(1, maxP - minP);
  const from = { r:147, g:197, b:253 };
  const to   = { r:59,  g:130, b:246 };
  const r = Math.round(from.r + (to.r - from.r)*t);
  const g = Math.round(from.g + (to.g - from.g)*t);
  const b = Math.round(from.b + (to.b - from.b)*t);
  return `rgba(${r},${g},${b},0.9)`;
}

function renderMetrics() {
  const wrap = document.getElementById("metrics");
  wrap.innerHTML = "";
  const keys = ["games", "bell", "cherry", "ice"];
  keys.forEach((k) => {
    const row = document.createElement("label");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.gap = "8px";

    const keySpan = document.createElement("span");
    keySpan.className = "key";
    keySpan.textContent = k;
    row.appendChild(keySpan);

    const input = document.createElement("input");
    input.type = "number";
    input.value = state.metrics[k] ?? "";
    input.oninput = (e)=>{
      const v = e.target.value === "" ? undefined : Number(e.target.value);
      state.metrics[k] = v;
      renderBars();
      renderMetrics(); // /G値の再描画
    };
    row.appendChild(input);

    const tail = document.createElement("span");
    tail.className = "perg";
    if (k !== "games" && state.metrics.games) {
      const val = ( (state.metrics[k] || 0) / (state.metrics.games || 1) ).toFixed(4);
      tail.textContent = "/G " + val;
    } else {
      tail.textContent = "";
    }
    row.appendChild(tail);

    wrap.appendChild(row);
  });
}

function renderBars() {
  const mount = document.getElementById("bars");
  const rows = estimateAllSettings(state.metrics);
  if (!rows.length) {
    mount.textContent = "必要な数値が揃うと比較グラフが表示されます。";
    return;
  }
  const perc = rows.map(r=>r.percent);
  const maxP = Math.max(...perc);
  const minP = Math.min(...perc);
  mount.innerHTML = "";
  rows.forEach((r)=>{
    const head = document.createElement("div");
    head.className = "rowline";
    head.innerHTML = `<span class="label">設定${r.setting}</span><span>${r.percent.toFixed(2)}%</span>`;
    const barWrap = document.createElement("div");
    barWrap.className = "bar-wrap";
    const bar = document.createElement("div");
    bar.className = "bar";
    bar.style.width = Math.max(0, Math.min(100, r.percent)) + "%";
    bar.style.background = barColor(r.percent, maxP, minP);
    barWrap.appendChild(bar);
    mount.appendChild(head);
    mount.appendChild(barWrap);
  });
}

function renderExtracted() {
  const mount = document.getElementById("extracted");
  if (!mount) return;
  const ex = state.metrics.extras || [];
  if (!ex.length) { mount.textContent = "まだ抽出結果がありません。"; return; }
  const rows = ex.map(e => 
    `<tr><td style="padding:4px 8px;border:1px solid #e5e7eb;">${e.label}</td>
         <td style="padding:4px 8px;border:1px solid #e5e7eb;text-align:right;">${e.value}</td>
         <td style="padding:4px 8px;border:1px solid #e5e7eb;">${e.unit || ""}</td></tr>`
  ).join("");
  mount.innerHTML = `<table style="border-collapse:collapse;font-size:12px;width:100%;">
    <thead><tr>
      <th style="text-align:left;padding:4px 8px;border:1px solid #e5e7eb;background:#f9fafb;">項目</th>
      <th style="text-align:right;padding:4px 8px;border:1px solid #e5e7eb;background:#f9fafb;">値</th>
      <th style="text-align:left;padding:4px 8px;border:1px solid #e5e7eb;background:#f9fafb;">単位</th>
    </tr></thead>
    <tbody>${rows}</tbody>
  </table>`;
}

function setError(msg) {
  const box = document.getElementById("err");
  if (!msg) { box.style.display = "none"; box.textContent = ""; return; }
  box.style.display = "block"; box.textContent = msg;
}

/* ===== 初期化 ===== */
function init() {
  try {
    const sample = "総プレイ数 6,000G\n風鈴合算 780回\nチェリー合算 380回\n氷合算 110回";
    const m = parseMetricsFromText(sample);
    console.assert(m.games===6000 && m.bell===780 && m.cherry===380 && m.ice===110, "parse ok");
  } catch {}

  renderMetrics();
  renderBars();
  renderExtracted();

  const file = document.getElementById("file");
  const thumb = document.getElementById("thumb");
  const btnOcr = document.getElementById("btn-ocr");
  const spin = document.getElementById("spin");
  const btnParse = document.getElementById("btn-parse");
  const text = document.getElementById("text");

  file.addEventListener("change", (e)=>{
    setError("");
    const f = e.target.files && e.target.files[0];
    if (!f) { thumb.style.display="none"; state.imgUrl=null; btnOcr.classList.add("disabled"); btnOcr.disabled=true; return; }
    const url = URL.createObjectURL(f);
    state.imgUrl = url;
    thumb.src = url; thumb.style.display = "inline-block";
    btnOcr.classList.remove("disabled"); btnOcr.disabled = false;
  });

  // GitHub Pages でも確実に読める相対パス
  const TESS_BASE = new URL("./tesseract/", location.href).href;

  btnOcr.addEventListener("click", async ()=>{
    if (!state.imgUrl) return;
    setError("");
    btnOcr.disabled = true; spin.style.display="inline-block"; btnOcr.firstChild.textContent = "画像から解析";
    try {
      const { createWorker } = window.Tesseract || {};
      if (!createWorker) throw new Error("Tesseract not loaded");
      const worker = await createWorker({
        workerPath: TESS_BASE + "worker.min.js",
        corePath:   TESS_BASE + "tesseract-core.wasm.js",
        langPath:   TESS_BASE + "lang-data",
        logger: ()=>{},
      });
      await worker.loadLanguage("jpn+eng");
      await worker.initialize("jpn+eng");
      const { data } = await worker.recognize(state.imgUrl);
      await worker.terminate();
      const t = (data && data.text) || "";
      state.ocrText = t;
      text.value = t;
      state.metrics = parseMetricsFromText(t);
      renderMetrics();
      renderBars();
      renderExtracted();
      if (!state.metrics.games) {
        setError("OCR結果から主要項目を特定できませんでした。テキスト欄で貼付け→「テキストから解析」をお試しください。");
      }
    } catch (e) {
      setError("OCRが使用できません。tesseract/ フォルダの配置とパスをご確認の上、テキスト貼付け→「テキストから解析」で続行できます。");
    } finally {
      btnOcr.disabled = false; spin.style.display="none";
    }
  });

  btnParse.addEventListener("click", ()=>{
    setError("");
    state.ocrText = text.value || "";
    state.metrics = parseMetricsFromText(state.ocrText);
    renderMetrics();
    renderBars();
    renderExtracted();
    if (!state.metrics.games) {
      setError("総プレイ数（○○G）が見つかりませんでした。貼り付けたテキストをご確認ください。");
    }
  });

  // tesseract.min.js を相対で読み込み試行（無くても動く）
  (function tryLoadTesseract(){
    const s = document.createElement("script");
    s.src = TESS_BASE + "tesseract.min.js";
    s.async = true;
    s.onload = ()=>{};
    s.onerror = ()=>{};
    document.head.appendChild(s);
  })();
}

init();
</script>
</body>
</html>
