<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>特リプTV｜新ハナビ｜思い出の数値</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", "Meiryo", sans-serif; margin: 24px; color: #111; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .hint { background: #fff7ed; border: 1px solid #fed7aa; color: #7c2d12; padding: 8px 10px; border-radius: 8px; font-size: 13px; }
    .error { background: #fef2f2; border: 1px solid #fecaca; color: #991b1b; padding: 8px 10px; border-radius: 8px; font-size: 13px; margin-top: 8px; display:none; }
    .row { display: flex; flex-wrap: wrap; align-items: center; gap: 8px; margin-top: 12px; }
    .btn { font-size: 13px; padding: 6px 10px; border-radius: 6px; border: 0; cursor: pointer; }
    .btn.primary { background: #111; color: #fff; }
    .btn.disabled { background: #d1d5db; color: #6b7280; cursor: not-allowed; }
    img.thumb { height: 112px; border: 1px solid #e5e7eb; border-radius: 8px; }
    .card { background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 10px; padding: 12px; margin-top: 12px; }
    .card h3 { margin: 0 0 8px; font-size: 14px; }
    textarea { width: 100%; height: 140px; border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 8px; }
    @media (min-width: 640px) { .grid { grid-template-columns: 1fr 1fr; } }
    label span.key { width: 72px; color: #6b7280; display: inline-block; }
    input[type="number"] { border: 1px solid #e5e7eb; border-radius: 6px; padding: 6px 8px; width: 100%; }
    .perg { font-size: 11px; color: #6b7280; width: 80px; text-align: right; }
    .bar-wrap { width: 100%; height: 16px; background: #e5e7eb; border-radius: 999px; overflow: hidden; }
    .bar { height: 16px; transition: width 300ms ease; }
    .rowline { display: flex; align-items: center; justify-content: space-between; font-size: 12px; margin-bottom: 4px; }
    .footer { margin-top: 16px; font-size: 12px; color: #6b7280; }
    code { background: #f3f4f6; padding: 0 4px; border-radius: 4px; }
    .spinner { display:none; width: 14px; height: 14px; border: 2px solid #fff; border-right-color: transparent; border-radius: 50%; animation: spin 0.6s linear infinite; margin-left:6px; }
    @keyframes spin { to { transform: rotate(360deg);} }
  </style>
</head>
<body>
  <h1>特リプTV｜新ハナビ｜思い出の数値</h1>
  <div class="hint">
    <strong>使い方:</strong> スクショを選んで「画像から解析」。失敗や未準備なら、下のテキスト欄に貼り付けて「テキストから解析」。<br/>
    iPhoneは画像を<strong>長押し → テキストをコピー</strong>でOK。貼り付けが「ラベル行 → 数値行」に分かれても自動で対応します。<br/>
    Option B（ローカル同梱）なら <code>tesseract/</code> フォルダに必要ファイルを置いてから再読み込み。
  </div>

  <div id="err" class="error"></div>

  <div class="row">
    <input id="file" type="file" accept="image/*" />
    <img id="thumb" class="thumb" style="display:none" alt="preview"/>
    <button id="btn-ocr" class="btn primary disabled" disabled>
      画像から解析 <span id="spin" class="spinner"></span>
    </button>
  </div>

  <div class="card">
    <div style="display:flex; align-items:center; justify-content:space-between;">
      <h3>テキスト（手動貼り付け）</h3>
      <button id="btn-parse" class="btn" style="background:#2563eb; color:#fff;">テキストから解析</button>
    </div>
    <textarea id="text" placeholder="例)
総プレイ数 6,056G
風鈴合算 813回 1/7.4
チェリー合算 381回 1/15.9
氷合算 103回 1/58.8"></textarea>
  </div>

  <div class="card">
    <h3>抽出メトリクス（編集可）</h3>
    <div class="grid" id="metrics"></div>
  </div>

  <div class="card">
    <h3>推測比較（最大=赤、最小=水色）</h3>
    <div id="bars">必要な数値が揃うと比較グラフが表示されます。</div>
  </div>

  <div class="footer">
    ローカルOCR：<code>tesseract/</code> に <code>worker.min.js</code>、<code>tesseract-core.wasm.js</code>、<code>tesseract.min.js</code>、および <code>lang-data/jpn.traineddata.gz</code> と <code>lang-data/eng.traineddata.gz</code> を配置。
  </div>

<script>
/* ===== プリセット ===== */
const PRESETS = {
  "新ハナビ": {
    bell:   [1/7.7,  1/7.6,  1/7.5,  1/7.3],
    cherry: [1/16.4, 1/15.3, 1/16.1, 1/15.6],
    ice:    [1/51.2, 1/51.8, 1/48.2, 1/49.3],
  },
};

const state = {
  imgUrl: null,
  ocrText: "",
  metrics: { games: undefined, bell: undefined, cherry: undefined, ice: undefined },
};

/* ===== ユーティリティ ===== */
function sanitize(s) {
  return (s || "")
    .replace(/[０-９]/g, d => String.fromCharCode(d.charCodeAt(0) - 0xFEE0))
    .replace(/[，]/g, ",").replace(/[．]/g, ".").replace(/[　]/g, " ")
    .replace(/\r/g, "");
}

const NUM_G  = /^\s*([0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)\s*G\s*$/i;
const NUM_KAI= /^\s*([0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)\s*回\s*$/;
const NUM_1DIV = /^\s*1\s*\/\s*([0-9]+(?:\.[0-9]+)?)\s*$/;
const NUM_PERCENT = /^\s*[0-9]+(?:\.[0-9]+)?\s*%\s*$/;

/* ===== テキスト → メトリクス抽出 =====
   1) まず従来の「同じ行にラベルと数値」形式を試す
   2) ダメなら「ラベル行が先、数値行が後」の二段構成を自動対応（zip）
*/
function parseMetricsFromText(rawText) {
  const text = sanitize(rawText);
  const lines = text.split(/\n+/).map(l => l.trim()).filter(Boolean);

  // 1) インライン抽出（同じ行にある場合）
  function pickInline(labelRe, unitRe) {
    const line = lines.find(l => labelRe.test(l) && unitRe.test(l));
    if (!line) return undefined;
    const m = line.match(/([0-9]{1,3}(?:,[0-9]{3})*|[0-9]+)/);
    return m ? Number(m[1].replace(/,/g, "")) : undefined;
  }

  let games  = pickInline(/総[ププ]レイ|総ゲーム|総プレイ数|ゲーム数|回転数/i, /G/i);
  let bell   = pickInline(/風鈴合算|風鈴\s*合算/i, /回/);
  let cherry = pickInline(/チェリー合算|チェリー\s*合算/i, /回/);
  let ice    = pickInline(/氷合算|氷\s*合算/i, /回/);

  // 2) 二段構成（ラベル列 → 数値列）へのフォールバック
  if ([games, bell, cherry, ice].some(v => v === undefined)) {
    const labels = [];
    const values = [];

    for (const l of lines) {
      if (NUM_G.test(l)) {
        const v = Number(l.replace(NUM_G, "$1").replace(/,/g,""));
        values.push({ unit:"G", value:v });
      } else if (NUM_KAI.test(l)) {
        const v = Number(l.replace(NUM_KAI, "$1").replace(/,/g,""));
        values.push({ unit:"回", value:v });
      } else if (NUM_1DIV.test(l) || NUM_PERCENT.test(l) || /^[0-9,]+枚$/.test(l)) {
        // 比率・％・枚数はスキップ（ラベルに紐付けない）
      } else if (/^[0-9,.\-\/%]+$/.test(l)) {
        // 数字の塊だが単位なし → ノイズ。無視
      } else {
        labels.push(l); // ラベル列
      }
    }

    // 値は「G」「回」のみをラベル順に割当て（比率行は除外済み）
    const labelToValue = {};
    let vi = 0;
    for (let li = 0; li < labels.length && vi < values.length; li++) {
      const lab = labels[li];
      const val = values[vi];
      labelToValue[lab] = val;
      vi++;
    }

    // 欲しいラベルたち（幅広い表記ゆれを許容）
    function findByLabel(keys, wantUnit) {
      const key = labels.find(lab => keys.some(re => re.test(lab)));
      if (!key) return undefined;
      const hit = labelToValue[key];
      if (!hit) return undefined;
      if (wantUnit && hit.unit !== wantUnit) return undefined;
      return hit.value;
    }

    games  ??= findByLabel([/総[ププ]レイ|総ゲーム|総プレイ数|ゲーム数|回転数/i], "G");
    bell   ??= findByLabel([/風鈴合算|風鈴\s*合算/i], "回");
    cherry ??= findByLabel([/チェリー合算|チェリー\s*合算/i], "回");
    ice    ??= findByLabel([/氷合算|氷\s*合算/i], "回");
  }

  return { games, bell, cherry, ice };
}

/* ===== 推測ロジック（変更なし） ===== */
function estimateAllSettings(metrics) {
  const g = metrics.games || 0;
  if (!g) return [];
  const perG = {
    bell:   (metrics.bell   || 0) / g,
    cherry: (metrics.cherry || 0) / g,
    ice:    (metrics.ice    || 0) / g,
  };
  const core = PRESETS["新ハナビ"];
  const base = [1,2,5,6];
  const rows = base.map((setting, idx) => {
    const err = Math.pow(perG.bell - core.bell[idx],2)
              + Math.pow(perG.cherry - core.cherry[idx],2)
              + Math.pow(perG.ice - core.ice[idx],2);
    const score = 1/(1+err);
    return { setting, err, score, percent: 0 };
  });
  const sum = rows.reduce((a,b)=>a+b.score,0) || 1;
  rows.forEach(r => r.percent = (r.score/sum)*100);
  return rows;
}

function barColor(p, maxP, minP) {
  if (p === maxP) return "rgba(239,68,68,0.85)";     // 赤
  if (p === minP) return "rgba(147,197,253,0.85)";   // 水色
  const t = (p - minP) / Math.max(1, maxP - minP);
  const from = { r:147, g:197, b:253 };
  const to   = { r:59,  g:130, b:246 };
  const r = Math.round(from.r + (to.r - from.r)*t);
  const g = Math.round(from.g + (to.g - from.g)*t);
  const b = Math.round(from.b + (to.b - from.b)*t);
  return `rgba(${r},${g},${b},0.9)`;
}

function renderMetrics() {
  const wrap = document.getElementById("metrics");
  wrap.innerHTML = "";
  const keys = ["games", "bell", "cherry", "ice"];
  keys.forEach((k) => {
    const row = document.createElement("label");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.gap = "8px";

    const keySpan = document.createElement("span");
    keySpan.className = "key";
    keySpan.textContent = k;
    row.appendChild(keySpan);

    const input = document.createElement("input");
    input.type = "number";
    input.value = state.metrics[k] ?? "";
    input.oninput = (e)=>{
      const v = e.target.value === "" ? undefined : Number(e.target.value);
      state.metrics[k] = v;
      renderBars();
      renderMetrics(); // /G値の再描画
    };
    row.appendChild(input);

    const tail = document.createElement("span");
    tail.className = "perg";
    if (k !== "games" && state.metrics.games) {
      const val = ( (state.metrics[k] || 0) / (state.metrics.games || 1) ).toFixed(4);
      tail.textContent = "/G " + val;
    } else {
      tail.textContent = "";
    }
    row.appendChild(tail);

    wrap.appendChild(row);
  });
}

function renderBars() {
  const mount = document.getElementById("bars");
  const rows = estimateAllSettings(state.metrics);
  if (!rows.length) {
    mount.textContent = "必要な数値が揃うと比較グラフが表示されます。";
    return;
  }
  const perc = rows.map(r=>r.percent);
  const maxP = Math.max(...perc);
  const minP = Math.min(...perc);
  mount.innerHTML = "";
  rows.forEach((r)=>{
    const head = document.createElement("div");
    head.className = "rowline";
    head.innerHTML = `<span class="label">設定${r.setting}</span><span>${r.percent.toFixed(2)}%</span>`;
    const barWrap = document.createElement("div");
    barWrap.className = "bar-wrap";
    const bar = document.createElement("div");
    bar.className = "bar";
    bar.style.width = Math.max(0, Math.min(100, r.percent)) + "%";
    bar.style.background = barColor(r.percent, maxP, minP);
    barWrap.appendChild(bar);
    mount.appendChild(head);
    mount.appendChild(barWrap);
  });
}

function setError(msg) {
  const box = document.getElementById("err");
  if (!msg) { box.style.display = "none"; box.textContent = ""; return; }
  box.style.display = "block"; box.textContent = msg;
}

/* ===== 初期化 ===== */
function init() {
  try {
    const sample = "総プレイ数 6,000G\n風鈴合算 780回\nチェリー合算 380回\n氷合算 110回";
    const m = parseMetricsFromText(sample);
    console.assert(m.games===6000 && m.bell===780 && m.cherry===380 && m.ice===110, "parse ok");
  } catch {}

  renderMetrics();
  renderBars();

  const file = document.getElementById("file");
  const thumb = document.getElementById("thumb");
  const btnOcr = document.getElementById("btn-ocr");
  const spin = document.getElementById("spin");
  const btnParse = document.getElementById("btn-parse");
  const text = document.getElementById("text");

  file.addEventListener("change", (e)=>{
    setError("");
    const f = e.target.files && e.target.files[0];
    if (!f) { thumb.style.display="none"; state.imgUrl=null; btnOcr.classList.add("disabled"); btnOcr.disabled=true; return; }
    const url = URL.createObjectURL(f);
    state.imgUrl = url;
    thumb.src = url; thumb.style.display = "inline-block";
    btnOcr.classList.remove("disabled"); btnOcr.disabled = false;
  });

  // ★ GitHub Pages でも確実に読める相対パスを算出
  const TESS_BASE = new URL("./tesseract/", location.href).href;

  btnOcr.addEventListener("click", async ()=>{
    if (!state.imgUrl) return;
    setError("");
    btnOcr.disabled = true; spin.style.display="inline-block"; btnOcr.firstChild.textContent = "画像から解析";
    try {
      const { createWorker } = window.Tesseract || {};
      if (!createWorker) throw new Error("Tesseract not loaded");
      const worker = await createWorker({
        // ★ 先頭スラッシュを使わず、相対パスで指定
        workerPath: TESS_BASE + "worker.min.js",
        corePath:   TESS_BASE + "tesseract-core.wasm.js",
        langPath:   TESS_BASE + "lang-data",
        logger: ()=>{},
      });
      await worker.loadLanguage("jpn+eng");
      await worker.initialize("jpn+eng");
      const { data } = await worker.recognize(state.imgUrl);
      await worker.terminate();
      const t = (data && data.text) || "";
      state.ocrText = t;
      text.value = t;
      state.metrics = parseMetricsFromText(t);
      renderMetrics();
      renderBars();
      if (!state.metrics.games) {
        setError("OCR結果から主要項目を特定できませんでした。テキスト欄で貼付け→「テキストから解析」をお試しください。");
      }
    } catch (e) {
      // ★ ここで“Failed to fetch”や404でも丁寧に案内
      setError("OCRが使用できません。tesseract/ フォルダの配置とパスをご確認の上、テキスト貼付け→「テキストから解析」で続行できます。");
    } finally {
      btnOcr.disabled = false; spin.style.display="none";
    }
  });

  btnParse.addEventListener("click", ()=>{
    setError("");
    state.ocrText = text.value || "";
    state.metrics = parseMetricsFromText(state.ocrText);
    renderMetrics();
    renderBars();
    if (!state.metrics.games) {
      setError("総プレイ数（○○G）が見つかりませんでした。貼り付けたテキストをご確認ください。");
    }
  });

  // ★ tesseract.min.js を相対で「読み込み試行」（無くても動く）
  (function tryLoadTesseract(){
    const s = document.createElement("script");
    s.src = TESS_BASE + "tesseract.min.js";
    s.async = true;
    s.onload = ()=>{};
    s.onerror = ()=>{};
    document.head.appendChild(s);
  })();
}

init();
</script>
</body>
</html>
