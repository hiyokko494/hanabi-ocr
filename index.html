<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>特リプTV｜設定推測ツール（多機種対応版：2025.10.12 Rev.8）</title>
<style>
/* スタイルシートは前回のものと同じ */
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;margin:24px;color:#111}
  h1{font-size:20px;margin:0 0 12px}
  .hint{background:#fff7ed;border:1px solid #fed7aa;color:#7c2d12;padding:8px 10px;border-radius:8px;font-size:13px}
  .error{background:#fef2f2;border:1px solid #fecaca;color:#991b1b;padding:8px 10px;border-radius:8px;font-size:13px;margin-top:8px;display:none}
  .card{background:#f9fafb;border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin-top:12px}
  .card h3{margin:0 0 8px;font-size:14px}
  textarea{width:100%;height:200px;border:1px solid #e5e7eb;border-radius:8px;padding:8px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:8px}
  @media(min-width:720px){.grid{grid-template-columns:1fr 1fr}}
  label span.key{width:150px;color:#374151;display:inline-block}
  input[type="number"]{border:1px solid #e5e7eb;border-radius:6px;padding:6px 8px;width:100%}
  .perg{font-size:11px;color:#6b7280;width:100px;text-align:right}
  .bar-wrap{width:100%;height:16px;background:#e5e7eb;border-radius:999px;overflow:hidden}
  .bar{height:16px;transition:width .3s ease}
  .rowline{display:flex;align-items:center;justify-content:space-between;font-size:12px;margin-bottom:4px}
  ul.log{margin:6px 0 0 18px;padding:0;font-size:12px;line-height:1.4}
  .opts{display:flex;gap:14px;align-items:center;font-size:13px;color:#374151;flex-wrap:wrap;margin-top:4px}
  .opts label{margin-right:8px;}
  .muted{color:#6b7280}
  .kv{display:flex;align-items:center;gap:8px}
  .secnote{font-size:12px;color:#6b7280;margin-top:4px}
  .pill{display:inline-block;background:#eef2ff;color:#3730a3;border-radius:999px;padding:2px 8px;font-size:11px}
  .two-col{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:1000px){.two-col{grid-template-columns:1fr 1fr}}
  .subgrid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  table{width:100%;border-collapse:collapse;font-size:12px}
  th,td{border:1px solid #e5e7eb;padding:6px 8px;text-align:left;vertical-align:top}
  th{background:#f3f4f6}
  .tag{display:inline-block;font-size:10px;padding:2px 6px;border-radius:6px;background:#f1f5f9;color:#0f172a;margin-left:6px}
  #machine-select { font-size: 16px; padding: 6px; border-radius: 6px; }
  .control-row { display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
</style>
</head>
<body>
<h1>特リプTV｜設定推測ツール（多機種対応版：2025.10.12 Rev.8）</h1>
<div class="card">
  <div class="control-row">
    <h3>機種選択</h3>
    <select id="machine-select">
      <option value="SHIN_HANABI">新ハナビ 専用</option>
      <option value="ALEX_BRIGHT">アレックス ブライト 専用</option>
    </select>
  </div>
</div>
<div class="hint">
  OCR崩れに強い抽出＋<b>編集モード</b>による数値修正に対応。<br>
  **総G**と**主要小役**の数値が抽出されているとグラフが表示されます。
  <small class="muted">※「未検出」は該当ラベルの近傍に有効な数値が見つからなかったことを示します。</small>
</div>
<div id="err" class="error"></div>
<div class="card">
  <div class="control-row">
    <h3>テキスト（手動貼り付け）</h3>
    <div class="opts">
      <label class="kv"><input id="edit-mode" type="checkbox"> 編集モード</label>
      <div id="machine-specific-opts"></div>
      <button id="btn-parse" class="btn" style="background:#2563eb;color:#fff;border:none;border-radius:8px;padding:6px 10px;">テキストから解析</button>
    </div>
  </div>
  <textarea id="text" placeholder="ここにユニメモの遊技履歴テキストを貼り付けてください。"></textarea>
  <div class="secnote">※OCRで <code>チェリー⏎合算</code> / <code>花火チャレンジ中⏎はずれ</code> などの行割れ、および不要なヘッダー文字は自動結合・無視されます。</div>
</div>
<div class="two-col">
  <div class="card">
    <h3>抽出メトリクス（編集可 / 編集モードOFFで固定）</h3>
    <div class="grid" id="metrics"></div>
  </div>
  <div class="card">
    <h3>抽出シグナル（読み取り専用）</h3>
    <div class="subgrid" id="signals"></div>
  </div>
</div>
<div class="card">
  <h3>抽出一覧（全項目）<span class="tag">読み取り専用</span></h3>
  <table id="table-all">
    <thead><tr><th>項目</th><th>回数</th><th>分母</th><th>備考</th></tr></thead>
    <tbody></tbody>
  </table>
</div>
<div class="card">
  <h3>推測比較（最大=赤、最小=水色／同値は中間色）</h3>
  <div id="bars">必要な数値が揃うと比較グラフが表示されます。</div>
</div>
<div class="card">
  <h3>抽出ログ</h3>
  <ul id="log" class="log"></ul>
</div>
<script>
/* === 機種別データ定義 === */
const MACHINE_DATA = {
  "SHIN_HANABI": {
    displayName: "新ハナビ",
    // 期待値 (/G) — 設定: 1,2,5,6
    EXPECT: {
      bell:  [1/7.7,  1/7.6,  1/7.5,  1/7.3],
      cherry:[1/16.4, 1/15.3, 1/16.1, 1/15.6],
      ice:   [1/51.2, 1/51.8, 1/48.2, 1/49.3],
    },
    // 分母レンジ
    RANGE: {
      bell:   [4.5, 10.5], cherry: [10, 25], ice: [35, 80],
      bb_slant:[7,  13], bb_rare: [400, 30000], rt_hc: [4.6, 6.6], rt_hg: [8.5, 14.5],
      // RB中ハズレは回数のみ
      rb_miss_count: [0, 5000], 
      // その他
      bellA:[10,30], bellB:[10,30], iceA:[35,90], iceB:[300,5000], chA1:[80,140], chA2:[15,30], chB:[150,450], total_any:[2,5000], oneMedal:[8,25], yohakuIce:[10,40], bbFlat:[1.0,2.0],
    },
    // 設定別期待分母
    EXPECT_DENOM: {
      bb_slant: {1:11.0, 2:9.0, 5:11.0, 6:9.0},
      bb_rare:  {1:16384,2:16384,5:16384,6:655.4},
      rt_hc_miss:{1:6.0,  2:5.8,  5:5.3,  6:5.1},
      rt_hg_miss:{1:13.4, 2:12.4, 5:10.1, 6:9.5},
      // RB中ハズレ回数は尤度計算に使わず、フラグ制約にのみ使うため期待値は設定しない
    },
    // 尤度重み (bb_rare は弱めに設定)
    WEIGHTS: { bell:1.0, cherry:1.0, ice:0.7, bb_slant:1.1, bb_rare:0.2, rt_hc_miss:1.0, rt_hg_miss:1.0, rb_miss:1.6 },
    // 設定リスト
    SETTINGS: [1, 2, 5, 6],
    // 必須メトリクス（総G除く）
    PRIMARY_METRICS: ["bell", "cherry", "ice", "rb_miss_count"],
    METRIC_LABELS: {games:"総G", bell:"風鈴合算（回）", cherry:"チェリー合算（回）", ice:"氷合算（回）", rb_miss_count:"RB中ハズレ（回）"},
    // OCR認識用正規表現 - 「回数」や「合計」の有無に対応
    REGEX: {
      bell: /風鈴\s*(?:合算|合計|全)(?:回数)?/, cherry: /チェリー\s*(?:合算|合計|全|チエリ)(?:回数)?/, ice: /氷\s*合算(?:回数)?/,
      bb_slant: /(風斜め揃い|斜め風鈴|風鈴B|風斜め揃|風鈴斜め揃)/, bb_rare: /(レア役|バラケ目|レア)/,
      rt_hc: /花火チャレンジ中はずれ/, rt_hg: /花火GAME中はずれ/,
      rb_miss_label: /(RB中ハズレ|ハズレ)/, // RB中詳細の近傍で探すためのラベル
    },
    // フラグ・チェックボックス
    OPTS_HTML: `
      <label class="kv"><input id="peace" type="checkbox"> ピースマーク出現（設定2以上確定）</label>
      <label class="kv"><input id="yohaku-hazure" type="checkbox"> 予告音氷ハズレ（設定5・6確定）</label>
    `,
    NOTES: {
      "レア役（バラケ目/BB中）": "BB中のベルの崩れ目", "1枚役": "RB中の1枚役", "予告音氷": "RB中の1枚役告知で氷揃い", "予告音氷（ハズレ）": "RB中の1枚役告知でハズレ目（設定5・6確定）", "RB中ハズレ": "RB中のリーチ目役のハズレ",
    }
  },
  "ALEX_BRIGHT": {
    displayName: "アレックス ブライト",
    // 期待値 (/G) — 設定: 1,2,5,6
    EXPECT: {
      wing:  [1/13.4, 1/13.0, 1/12.6, 1/12.2], // 羽
      three_medal:[1/40.5, 1/38.1, 1/39.2, 1/38.3], // 3枚役
      cherryA_sum:[1/28.3, 1/28.4, 1/26.6, 1/26.5], // チェリー合算（旧：チェリーA合算）
      cherryB: [1/82.6, 1/82.1, 1/78.8, 1/76.7], // チェリーB
      grape_sum:[1/256.0, 1/256.0, 1/256.0, 1/256.0], // ブドウ合算（設定差不明のため設定1の値で固定）
    },
    // 分母レンジ
    RANGE: {
      wing:   [10, 15], three_medal: [30, 45], cherryA_sum: [18, 35], cherryB: [60, 95], grape_sum: [200, 350],
      bb_reach_hazure: [700, 30000], // BB中リーチ目ハズレ
      rb_special_end: [0, 5000], // RB特殊終了画面表示回数（回数のみ）
      bb_wing_hahan: [1.0, 5000.0], // BB中羽羽鳥C
      // その他
      total_any:[2,5000],
    },
    // 設定別期待分母（BB中リーチ目ハズレの重みを非常に強くする）
    EXPECT_DENOM: {
      bb_reach_hazure:  {1:21845.3, 2:21845.3, 5:744.7, 6:1489.5},
      rb_special_end:   {1:128.0, 2:128.0, 5:128.0, 6:20.0}, // 1/128 or 1/20 (RB終了時)
    },
    // 尤度重み (リーチ目ハズレの重みを非常に強くし、設定5/6の確定を演出)
    WEIGHTS: { wing:1.0, three_medal:1.0, cherryA_sum:1.0, cherryB:1.0, grape_sum:0.1, bb_reach_hazure:3.0, rb_special_end:1.5 },
    // 設定リスト
    SETTINGS: [1, 2, 5, 6],
    // 必須メトリクス（総G除く）
    PRIMARY_METRICS: ["wing", "three_medal", "cherryA_sum", "cherryB", "grape_sum"],
    METRIC_LABELS: {
      games:"総G", wing:"羽（回）", three_medal:"3枚役（回）", cherryA_sum:"チェリー合算（回）", // <-- ラベルから 'A' を削除 (Rev.7)
      cherryB:"チェリーB（回）", grape_sum:"ブドウ合算（回）"
    },
    // OCR認識用正規表現 - 「回数」や「合計」の有無に対応
    REGEX: {
      wing: /羽\b|羽(?:合算|合計)(?:回数)?/, 
      three_medal: /(3枚役|羽鳥回数)(?:回数)?/, 
      cherryA_sum: /チェリー\s*(?:合算|合計)(?:回数)?/, // <-- 正規表現から 'A' を削除し、汎用的に (Rev.7)
      cherryB: /チェリーB(?:回数)?/, 
      grape_sum: /ブドウ(?:合算|合計)(?:回数)?/,
      bb_reach_hazure_label: /リーチ目(?:ハズレ|ハズレ目)/, // BB中詳細の近傍で探す
      rb_special_end_label: /RB特殊終了画面表示回数/, // その他の近傍で探す
      bb_wing_hahan: /BB中羽羽鳥C/,
      bb_reach_manually: /BB中リーチ目（ハズレ）/ // 抽出シグナルからの手動フラグ
    },
    // フラグ・チェックボックス
    OPTS_HTML: `
      <label class="kv"><input id="bb_reach_hazure_flag" type="checkbox"> BB中リーチ目（ハズレ）出現（設定5・6濃厚）</label>
    `,
    NOTES: {
      "羽（通常時）": "高設定ほど出現", "3枚役（通常時）": "設定2が最も出現", "チェリー合算": "A①とA②の合算", "ブドウ合算": "AとBの合算",
      "BB中リーチ目ハズレ": "特大の設定差、出現で設定5・6濃厚",
      "RB特殊終了画面表示回数": "RB終了時のアレックス図柄（壁画）画面",
      "BB中羽羽鳥C回数": "偶数設定ほど出現"
    }
  }
};
let currentMachine = MACHINE_DATA.ALEX_BRIGHT;
const state = {
  metrics:{},
  extra:{},
  flags:{ peace:false, edit:false, yohakuHazure:false, bb_reach_hazure_flag:false }, // フラグ初期化
  allItems:[],
  log:[],
  currentMachineKey: "ALEX_BRIGHT"
};
/* ---------- Utils ---------- */
const $ = (id)=>document.getElementById(id);
function toNum(x){ if(x==null) return undefined; const n=Number(String(x).replace(/,/g,'')); return Number.isFinite(n)?n:undefined; }
function pushLog(msg){ state.log.push(msg); }
function setError(msg){ const e=$("err"); e.style.display=msg?"block":"none"; e.textContent=msg||""; }
function setText(id, s){ const el=$(id); el.textContent=s; el.classList.toggle("muted", s.includes("未検出") || s==="—"); }
/* サニタイズ */
function sanitize(s){
  return (s||"")
    .replace(/[０-９]/g, d=>String.fromCharCode(d.charCodeAt(0)-0xFEE0))
    .replace(/[，]/g, ",").replace(/[．]/g, ".")
    .replace(/[：:]\s*/g, ": ")
    .replace(/[　]/g, " ")
    .replace(/[／]/g, "/")
    .replace(/\s+\/\s+/g, "/")
    .replace(/\s{2,}/g, " ")
    // ヘッダー・不要文字の削除（ユニメモ対策）
    .replace(/遊技履歴\s*全[0-9]+件/g, "")
    .replace(/[0-9]{4}\/[0-9]{2}-[0-9]+件/g, "")
    .replace(/[0-9]{8,}/g, "") // 1015081110533 などの長い数字列
    .replace(/基本情報|設定推測/g, "")
    .trim();
}
/* ===== 行連結（OCRの見出し割れ修正） ===== */
function coalesceLines(lines){
  const out=[];
  for(let i=0;i<lines.length;i++){
    let cur=lines[i];
    // 総プレイ数/G 連結
    if(/^(総プレイ数|総回転数|プレイG|総ゲーム数)\s*$/.test(cur) && i+1<lines.length && /^[0-9,]+\s*G\s*$/i.test(lines[i+1])){
        out.push(lines[i+1]); i++; continue; 
    }
    // 小役 合算 連結
    if(/^(風鈴|チェリー|氷|チエリ|羽|ブドウ)\s*$/.test(cur) && i+1<lines.length && /^(合算|合計|全)\s*$/.test(lines[i+1])){
      out.push(RegExp.$1 + "合算"); i++; continue;
    }
    // 花火チャレンジ/GAME中 はずれ 連結
    if(/^花火チャレンジ中\s*$/.test(cur) && i+1<lines.length && /^(?:はずれ|ハズレ|ハズレ目|はずい|歳机)\s*$/.test(lines[i+1])){
      out.push("花火チャレンジ中はずれ"); i++; continue;
    }
    if(/^花火GAME中\s*$/.test(cur) && i+1<lines.length && /^(?:はずれ|ハズレ|ハズレ目|はずい|歳机)\s*$/.test(lines[i+1])){
      out.push("花火GAME中はずれ"); i++; continue;
    }
    // レア役（バラケ目）連結
    if(/^レア役\s*$/.test(cur) && i+1<lines.length && /[()（].*バラケ目.*[)）]\s*$/.test(lines[i+1])){
      out.push("レア役（バラケ目）"); i++; continue;
    }
    out.push(cur);
  }
  return out;
}
/* パターン */
const RE_G_ONLY   = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*G\s*$/i;
const RE_KAI_LIKE = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*(?:回|囘|问|n|曰|日)?\s*$/i; // Count only line (start/end anchors)
const RE_COUNT_GLOBAL = /([0-9]{1,3}(?:,[0-9]{3})*)\s*(?:回|囘|问|n|曰|日)/i; // Count anywhere in the line (Rev.8)
const RE_FRAC_ANY = /[1Iｌl]\s*[\/\\।]\s*([0-9][0-9,]*(?:\.[0-9]+)?)/; 
function countFrac(line){
  // Note: This function is mostly designed for lines that *only* contain the count/frac, 
  // as RE_KAI_LIKE has ^$ anchors. It is only used here for `collectAllPairs` and is not used in `pickNearBy`'s main logic in Rev.8.
  const c=line.match(RE_KAI_LIKE);
  const f=line.match(RE_FRAC_ANY);
  const denom=f?parseFloat(f[1].replace(/,/g,'')):undefined;
  return { count:c?toNum(c[1]):undefined, denom };
}
/* 文書全体の「回+1/◯」候補 */
function collectAllPairs(lines){
  const pairs=[];
  for(let i=0;i<lines.length;i++){
    const {count,denom}=countFrac(lines[i]); // Uses RE_KAI_LIKE (^$)
    if(count!=null && denom!=null){ pairs.push({idx:i,count,denom}); continue; }
    const c=lines[i].match(RE_KAI_LIKE);
    const f=(i+1<lines.length)?lines[i+1].match(RE_FRAC_ANY):null;
    // 回数のみの行の次に 1/◯ が来るパターン
    if(c && f){ pairs.push({idx:i,count:toNum(c[1]),denom:parseFloat(f[1].replace(/,/g,''))}); i++; }
  }
  pushLog(`pairs: ${pairs.length}件収集`);
  return pairs;
}
/**
 * 近傍探索（ウィンドウサイズを5行に狭くした）
 * @param {string[]} lines - テキストの行配列
 * @param {number} labelIdx - ラベルのインデックス
 * @param {number} window - 探索する行数 (例: 5)
 * @param {number[]} range - 許容する分母の範囲 [lo, hi]
 * @returns {{count: number, denom: number, idx: number}|null}
 */
function pickNearBy(lines, labelIdx, window, range){
  if(labelIdx<0) return null;
  const [lo,hi]=range;
  let best=null, bestDist=1e9;
  for(let j=Math.max(0,labelIdx-window); j<Math.min(lines.length,labelIdx+window+1); j++){
    let currentBest = null;
    const line = lines[j];

    // Case A: Count and Denom on the same line (allowing text/label before them)
    // Rev.8 Fix: Use RE_COUNT_GLOBAL instead of RE_KAI_LIKE (^$) to find the count anywhere in the line.
    const c_match = line.match(RE_COUNT_GLOBAL);
    const f_match = line.match(RE_FRAC_ANY);
    
    if (c_match && f_match) {
        const count = toNum(c_match[1]); 
        const denom = parseFloat(f_match[1].replace(/,/g,''));
        if(count!=null && Number.isFinite(denom) && denom>=lo && denom<=hi){
            currentBest = {count, denom, idx:j};
        }
    }

    // Case B: Count on line j (Count only line), Denom on line j+1
    // RE_KAI_LIKE still uses ^$ to ensure it's a pure count line, preventing accidental match on a label line.
    if (!currentBest && j+1 < lines.length) {
        const c=line.match(RE_KAI_LIKE); 
        const f=lines[j+1].match(RE_FRAC_ANY);
        
        if(c && f){
            const cnt=toNum(c[1]); const den=parseFloat(f[1].replace(/,/g,''));
            if(cnt!=null && Number.isFinite(den) && den>=lo && den<=hi){
                currentBest = {count:cnt, denom:den, idx:j}; 
            }
        }
    }
    
    if (currentBest) {
      const dist=Math.abs(currentBest.idx-labelIdx);
      if(dist<bestDist){ best=currentBest; bestDist=dist; }
    }
  }
  return best;
}
/* ラベル→近傍探索のみ (フォールバック排除: 誤検知対策) - Rev.7でフォールバックを削除 */
function resolveMetric(lines, labelRegex, range, labelKey, globalPairs /* 参照しない */){
  const idx=lines.findIndex(l=>labelRegex.test(l));
  // 近傍探索ウィンドウを 5行 に限定
  let got=pickNearBy(lines, idx, 5, range); 
  
  if(got){
    pushLog(`${labelKey||'項目'}: 近傍採用 idx=${got.idx} → ${got.count??'-'}回 (1/${got.denom??'-'})`);
  } else if (idx >= 0) {
     pushLog(`${labelKey||'項目'}: ラベル検出 (${idx})。近傍に有効な数値ペア見つからず（分母範囲: 1/${range[0]}〜1/${range[1]}）`);
  } else {
     pushLog(`${labelKey||'項目'}: ラベル見つからず`);
  }
  return got;
}
/* 回数のみを近傍から探す（分母がないもの） */
function pickCountNear(lines, labelIdx, window, countLabelRe, rejectFrac=true){
  if(labelIdx<0) return undefined;
  let best=undefined, bestDist=1e9;
  for(let j=Math.max(0,labelIdx-window); j<Math.min(lines.length,labelIdx+window+1); j++){
    const line = lines[j];
    // ラベル行またはその近傍で回数のみを探す
    // Rev.8: RE_COUNT_GLOBAL を使用し、行のどこに回数があっても検出可能に。
    const c=line.match(RE_COUNT_GLOBAL); 
    // countLabelRe が指定されている場合、そのラベル行自身とその近傍の行を探索
    const isTargetLabel = countLabelRe ? countLabelRe.test(line) : true;
    
    if(c && isTargetLabel){
      const cnt=toNum(c[1]);
      // rejectFrac=true の場合、この行に分母が含まれていないことを確認（誤検知対策）
      if(cnt!=null && (!rejectFrac || line.match(RE_FRAC_ANY) === null)){
        const dist=Math.abs(j-labelIdx);
        if(dist<bestDist){ best=cnt; bestDist=dist; }
      }
    }
  }
  return best;
}
/* === 解析本体 === */
function parseMetricsFromText(raw){
  state.log = [];
  state.allItems = [];
  
  const t = sanitize(raw);
  const rawLines = t.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const lines = coalesceLines(rawLines);
  const out = {games:undefined};
  currentMachine.PRIMARY_METRICS.forEach(k => out[k] = undefined);
  const extra = {};
  
  // 総G：G-only最大
  const cands = lines.map(ln=>{ const m=RE_G_ONLY.exec(ln); return m?toNum(m[1]):null; }).filter(v=>v!=null);
  if(cands.length){ out.games = Math.max(...cands); pushLog(`総G: G-only最大 → ${out.games}`); } else pushLog("総G: 見つからず");
  const allPairs = collectAllPairs(lines); // Rev.7では主要小役の抽出には使わない
  // PRIMARY METRICS の抽出
  currentMachine.PRIMARY_METRICS.forEach(key => {
    const labelRe = currentMachine.REGEX[key];
    const range = currentMachine.RANGE[key];
    if (labelRe && range) {
      // RB中ハズレ/特殊終了画面（回数のみの項目）は近傍の回数を優先
      if (key === "rb_miss_count" && state.currentMachineKey === "SHIN_HANABI") {
        const rbIdx = lines.findIndex(l=>/(RB中詳細|RB中詳)/.test(l));
        const count = pickCountNear(lines, rbIdx, 5, currentMachine.REGEX.rb_miss_label, true); // window=5
        out.rb_miss_count = count; // state.metricsに入れる
        extra.rb_miss_count = count; // extraにも入れる
        if(Number.isFinite(count)) addItem(currentMachine.METRIC_LABELS[key].replace(/（回）/, ""), count, null);
      } else if (key === "rb_special_end" && state.currentMachineKey === "ALEX_BRIGHT") {
        // RB特殊終了画面表示回数（回数のみ）- ロジックを pickCountNear に変更 (rejectFrac=trueを適用)
        const rbSpecialEndIdx = lines.findIndex(l=>currentMachine.REGEX.rb_special_end_label.test(l));
        const rbEndCount = pickCountNear(lines, rbSpecialEndIdx, 5, currentMachine.REGEX.rb_special_end_label, true); // window=5
        extra.rb_special_end_count = Number.isFinite(rbEndCount) ? rbEndCount : 0;
        if(Number.isFinite(rbEndCount)) addItem("RB特殊終了画面表示回数", rbEndCount, null);
      }
      // 通常の小役 (Rev.7: フォールバックを排除)
      const result = resolveMetric(lines, labelRe, range, key, allPairs);
      if (result) {
        out[key] = result.count;
        extra[`${key}_den`] = result.denom;
        addItem(currentMachine.METRIC_LABELS[key].replace(/（回）/, ""), result.count, result.denom);
      }
    }
  });
  // EXTRA SIGNALS の抽出
  if (state.currentMachineKey === "SHIN_HANABI") {
    const bbSlant = pickNearBy(lines, lines.findIndex(l=>currentMachine.REGEX.bb_slant.test(l)), 5, currentMachine.RANGE.bb_slant);
    if(bbSlant){ extra.bb_slant_den = bbSlant.denom; addItem("風斜め揃い（BB中）", bbSlant.count, bbSlant.denom); }
    const bbRare = pickNearBy(lines, lines.findIndex(l=>currentMachine.REGEX.bb_rare.test(l)), 5, currentMachine.RANGE.bb_rare);
    if(bbRare){ extra.bb_rare_den = bbRare.denom; addItem("レア役（バラケ目/BB中）", bbRare.count, bbRare.denom); }
    const rtHC = pickNearBy(lines, lines.findIndex(l=>currentMachine.REGEX.rt_hc.test(l)), 5, currentMachine.RANGE.rt_hc);
    if(rtHC){ extra.rt_hc_den = rtHC.denom; addItem("花火チャレンジ中はずれ", rtHC.count, rtHC.denom); }
    const rtHG = pickNearBy(lines, lines.findIndex(l=>currentMachine.REGEX.rt_hg.test(l)), 5, currentMachine.RANGE.rt_hg);
    if(rtHG){ extra.rt_hg_den = rtHG.denom; addItem("花火GAME中はずれ", rtHG.count, rtHG.denom); }
  } else if (state.currentMachineKey === "ALEX_BRIGHT") {
    // BB中 リーチ目ハズレ（分母）
    const bbReachHazure = pickNearBy(lines, lines.findIndex(l=>currentMachine.REGEX.bb_reach_hazure_label.test(l)), 5, currentMachine.RANGE.bb_reach_hazure);
    if(bbReachHazure){ extra.bb_reach_hazure_den = bbReachHazure.denom; addItem("BB中リーチ目ハズレ", bbReachHazure.count, bbReachHazure.denom); }
    
    // BB中 羽羽鳥C（回数または1/◯）
    const bbWingHahan = pickNearBy(lines, lines.findIndex(l=>currentMachine.REGEX.bb_wing_hahan.test(l)), 5, currentMachine.RANGE.bb_wing_hahan);
    if(bbWingHahan){ extra.bb_wing_hahan_den = bbWingHahan.denom; extra.bb_wing_hahan_count = bbWingHahan.count; addItem("BB中羽羽鳥C回数", bbWingHahan.count, bbWingHahan.denom); }
    
    // BB中リーチ目（手動）フラグの自動検知
    if(!state.flags.bb_reach_hazure_flag && extra.bb_reach_hazure_den && extra.bb_reach_hazure_den < 5000) {
      pushLog("BB中リーチ目ハズレの分母が検出されたため、設定5・6濃厚フラグを自動検知しました。");
      state.flags.bb_reach_hazure_flag = true;
    }
  }
  // 内訳・ボーナス・その他（機種共通・近傍探索のみ）
  addDetailMetrics(lines, allPairs);
  
  // フラグの自動検知
  if (state.currentMachineKey === "SHIN_HANABI") {
    // 省略
  } else if (state.currentMachineKey === "ALEX_BRIGHT") {
    // RB特殊終了画面表示回数が1回以上ならフラグを立てる（尤度計算に使用）
    if(Number.isFinite(extra.rb_special_end_count) && extra.rb_special_end_count >= 1) {
      pushLog("RB特殊終了画面表示回数が1回以上検出されたため、尤度計算に反映します。");
      extra.rb_special_end_flag = true;
    } else {
      extra.rb_special_end_flag = false;
    }
  }
  // 検出されなかった小役の count/den をログに追記
  const primaryKeys = currentMachine.PRIMARY_METRICS.filter(k => k !== "rb_miss_count");
  const logSummary = primaryKeys.map(k => `${k}=${out[k]??'-'} (1/${extra[`${k}_den`]??"-"})`).join(' | ');
  pushLog(`summary: games=${out.games??'-'} | ${logSummary}`);
  // 抽出結果をstateに反映
  state.metrics = {...state.metrics, ...out};
  state.extra = {...state.extra, ...extra}; 
  
  // 総Gの値をUIに確実に反映 (Rev.3で追加)
  const gameInput = $("inp-games");
  if (gameInput) gameInput.value = state.metrics.games ?? "";
  updateSignals(state.extra);
  renderAllTable();
  return state.metrics;
  function addItem(name, count, denom){
    // 重複チェック: 同じ名前で、回数も分母も同じ値を持つ項目は追加しない
    const exists = state.allItems.some(item => 
      item.name === name && 
      item.count === count && 
      item.denom === denom
    );
    if(!exists) {
      state.allItems.push({name, count: (Number.isFinite(count)? count : null), denom: (Number.isFinite(denom)? denom : null)});
    }
  }
  function addDetailMetrics(lines, allPairs){
    const machine = currentMachine;
    // 内訳（A/B等） - これらの項目は fallback を使わない
    addByLabelNear(lines, /羽A回数/, "羽A回数", machine.RANGE.bellA || [10,30]);
    addByLabelNear(lines, /羽B回数/, "羽B回数", machine.RANGE.bellB || [10,30]);
    addByLabelNear(lines, /氷A/,   "氷A",   machine.RANGE.iceA || [35,90]);
    addByLabelNear(lines, /氷B/,   "氷B",   machine.RANGE.iceB || [300,5000]);
    addByLabelNear(lines, /チェリーA1回数/, "チェリーA1回数", machine.RANGE.chA1 || [80,140]);
    addByLabelNear(lines, /チェリーA2回数/, "チェリーA2回数", machine.RANGE.chA2 || [15,30]);
    addByLabelNear(lines, /チェリーB回数/,  "チェリーB回数",  machine.RANGE.chB || [150,450]);
    // 総ボーナス系
    addByLabelNear(lines, /総ボーナス回数/, "総ボーナス回数", machine.RANGE.total_any || [2,5000]);
    addByLabelNear(lines, /総BB回数/, "総BB回数", machine.RANGE.total_any || [2,5000]);
    addByLabelNear(lines, /赤７BB回数/, "赤7BB回数", machine.RANGE.total_any || [2,5000]);
    addByLabelNear(lines, /青７BB回数/, "青7BB回数", machine.RANGE.total_any || [2,5000]);
    addByLabelNear(lines, /総RB回数/, "総RB回数", machine.RANGE.total_any || [2,5000]);
    // 1枚役／予告音氷 (新ハナビ)
    if (state.currentMachineKey === "SHIN_HANABI") {
        addByLabelNear(lines, /1枚役/, "1枚役", machine.RANGE.oneMedal || [8,25]);
        addByLabelNear(lines, /予告音氷/, "予告音氷", machine.RANGE.yohakuIce || [10,40]);
    }
    // BB中詳細 (アレックス)
    if (state.currentMachineKey === "ALEX_BRIGHT") {
        addByLabelNear(lines, /BB中羽鳥A回数/, "BB中羽羽鳥A回数", [1.0, 5000.0]);
        addByLabelNear(lines, /BB中羽鳥B回数/, "BB中羽羽鳥B回数", [1.0, 5000.0]);
        // BB中羽羽鳥Cはextraで処理済みだが、addItem用に再度実行
        const bbWingHahanC = pickNearBy(lines, lines.findIndex(l=>currentMachine.REGEX.bb_wing_hahan.test(l)), 5, currentMachine.RANGE.bb_wing_hahan);
        if(bbWingHahanC) addItem("BB中羽羽鳥C回数", bbWingHahanC.count, bbWingHahanC.denom);
        addByLabelNear(lines, /BB中ブドウ回数/, "BB中ブドウ回数", [1.0, 5000.0]);
    }
    // その他 (アレックス)
    addByLabelNear(lines, /最大連続羽回数/, "最大連続羽回数", [1,20], true, false); 
    addByLabelNear(lines, /最大連続同色羽回数/, "最大連続同色羽回数", [1,20], true, false);
    // RB特殊終了画面表示回数は分母を持たないため、別処理（parseMetricsFromTextで実施済み）
  }
  function addByLabelNear(lines, labelRe, labelName, range, isCountOnly=false, requireDenom=true){
    // fallbackを使わず、近傍探索のみを実行
    const idx=lines.findIndex(l=>labelRe.test(l));
    if(idx<0) return;
    
    if (isCountOnly) {
        const count = pickCountNear(lines, idx, 5, labelRe, true); // window=5, 回数のみ（分母拒否）
        if(Number.isFinite(count)) addItem(labelName, count, null);
    } else if (requireDenom) {
        const got = pickNearBy(lines, idx, 5, range); // window=5
        if(got) addItem(labelName, got.count, got.denom);
    }
  }
}
/* ---------- 推測（尤度ベース：二項ログ尤度 + 追加指標のガウス罰則） ---------- */
function estimateAllSettings(m){
  const g = toNum(m.games)||0; if(!g) return [];
  const EPS=1e-9, clamp01=(p)=>Math.min(1-EPS,Math.max(EPS,p));
  const ll_binom=(k,n,p)=>{p=clamp01(p); const q=1-p; return k*Math.log(p)+(n-k)*Math.log(q);};
  const penalty_denom=(d,exp,w)=>(!Number.isFinite(d)||!Number.isFinite(exp))?0:(-w*Math.pow((d-exp)/exp,2)/(2*Math.pow(0.12,2)));
  const settings=currentMachine.SETTINGS;
  const metricsKeys = currentMachine.PRIMARY_METRICS.filter(k => k !== "rb_miss_count"); // rb_miss_count は別途処理
  const rows=settings.map((s,i)=>{
    let ll=0, used=0;
    
    // PRIMARY METRICS
    metricsKeys.forEach(key => {
      const count = toNum(m[key]);
      if (Number.isFinite(count)) {
        const p = currentMachine.EXPECT[key][i];
        ll += currentMachine.WEIGHTS[key] * ll_binom(count, g, p);
        used++;
      }
    });
    
    // SHIN_HANABI SIGNALS
    if (state.currentMachineKey === "SHIN_HANABI") {
      if(state.extra.bb_slant_den){ ll+=penalty_denom(state.extra.bb_slant_den, currentMachine.EXPECT_DENOM.bb_slant[s], currentMachine.WEIGHTS.bb_slant); used++; }
      if(state.extra.bb_rare_den){ ll+=penalty_denom(state.extra.bb_rare_den, currentMachine.EXPECT_DENOM.bb_rare[s], currentMachine.WEIGHTS.bb_rare); used++; }
      if(state.extra.rt_hc_den){ ll+=penalty_denom(state.extra.rt_hc_den, currentMachine.EXPECT_DENOM.rt_hc_miss[s], currentMachine.WEIGHTS.rt_hc_miss); used++; }
      if(state.extra.rt_hg_den){ ll+=penalty_denom(state.extra.rt_hg_den, currentMachine.EXPECT_DENOM.rt_hg_miss[s], currentMachine.WEIGHTS.rt_hg_miss); used++; }
      
      const rb_miss_count = toNum(state.extra.rb_miss_count); // extraから取得
      if(Number.isFinite(rb_miss_count)){
        if(rb_miss_count===0){ 
          if(s===5||s===6){ ll += currentMachine.WEIGHTS.rb_miss*1.5; used++; }
        } else if(rb_miss_count>0){ 
          if(s===1||s===2){ ll -= currentMachine.WEIGHTS.rb_miss*(1+rb_miss_count); used++; }
          if(s===5||s===6){ ll += currentMachine.WEIGHTS.rb_miss*Math.min(1,rb_miss_count*0.2); used++; }
        }
      }
      // フラグ制約
      if(s===1 && state.flags.peace){ ll = -Infinity; used++; }           
      if((s===1||s===2) && state.flags.yohakuHazure){ ll = -Infinity; used++; } 
    } 
    // ALEX_BRIGHT SIGNALS
    else if (state.currentMachineKey === "ALEX_BRIGHT") {
      // BB中リーチ目ハズレ
      let bbReachDen = state.extra.bb_reach_hazure_den;
      // 手動チェックまたは自動検知でフラグがONの場合は、設定1,2を-Infinityにする
      if(state.flags.bb_reach_hazure_flag){
        if(s===1||s===2){ ll = -Infinity; used++; } 
      } else if (bbReachDen) {
         // 分母が検出された場合は、尤度計算に反映
         ll+=penalty_denom(bbReachDen, currentMachine.EXPECT_DENOM.bb_reach_hazure[s], currentMachine.WEIGHTS.bb_reach_hazure); used++; 
      }
      
      // REG終了画面アレックス図柄（RB特殊終了画面表示回数）
      if(state.extra.rb_special_end_flag){ // フラグで判定
         if(s===6){ ll += currentMachine.WEIGHTS.rb_special_end * 3; used++; }
         else { ll -= currentMachine.WEIGHTS.rb_special_end * 1; used++; } // 設定6以外に罰則
      }
      
      // BB中羽羽鳥C
      if(state.extra.bb_wing_hahan_den){
        ll+=penalty_denom(state.extra.bb_wing_hahan_den, currentMachine.EXPECT_DENOM.rb_special_end[s], currentMachine.WEIGHTS.rb_special_end * 0.5); 
      }
    }
    
    return {setting:s, ll: used? ll : -Infinity};
  });
  const maxLL=Math.max(...rows.map(r=>r.ll));
  const expS=rows.map(r=>Math.exp(r.ll-maxLL));
  const sumS=expS.reduce((a,b)=>a+b,0)||1;
  return rows.map((r,i)=>({setting:r.setting, score:expS[i], percent:(expS[i]/sumS)*100}));
}
/* ---------- UI ---------- */
function barColor(p,max,min){
  if(max===min) return "rgba(96,165,250,0.85)";
  if(p===max) return "rgba(239,68,68,0.85)";
  if(p===min) return "rgba(147,197,253,0.85)";
  const t=(p-min)/Math.max(1,(max-min));
  const r=Math.round(147+(59-147)*t), g=Math.round(197+(130-197)*t), b=Math.round(253+(246-253)*t);
  return `rgba(${r},${g},${b},0.9)`;
}
function renderBars(){
  const mount=$("bars");
  const rows=estimateAllSettings(state.metrics);
  if(!rows.length){ mount.textContent="必要な数値が揃うと比較グラフが表示されます。"; return; }
  const perc=rows.map(r=>r.percent), max=Math.max(...perc), min=Math.min(...perc);
  mount.innerHTML="";
  rows.forEach(r=>{
    const head=document.createElement("div"); head.className="rowline";
    head.innerHTML=`<span>${currentMachine.displayName}｜設定${r.setting}</span><span>${r.percent.toFixed(2)}%</span>`;
    const barWrap=document.createElement("div"); barWrap.className="bar-wrap";
    const bar=document.createElement("div"); bar.className="bar";
    bar.style.width = Math.max(0, Math.min(100, isFinite(r.percent)? r.percent : 0)) + "%";
    bar.style.background = barColor(r.percent,max,min);
    barWrap.appendChild(bar);
    mount.appendChild(head); mount.appendChild(barWrap);
  });
}
function updateSignals(ex){
  const signalsEl = $("signals");
  signalsEl.innerHTML = "";
  
  if (state.currentMachineKey === "SHIN_HANABI") {
    signalsEl.innerHTML = `
      <div><span class="key">BB斜め風鈴</span><span id="sig-bb-slant" class="pill muted">未検出</span></div>
      <div><span class="key">BBレア役(バラケ目)</span><span id="sig-bb-rare" class="pill muted">未検出</span></div>
      <div><span class="key">HCはずれ</span><span id="sig-rt-hc" class="pill muted">未検出</span></div>
      <div><span class="key">HGはずれ</span><span id="sig-rt-hg" class="pill muted">未検出</span></div>
      <div style="grid-column: 1 / 3;"><span class="key">RB中ハズレ（回）</span><span id="sig-rb-miss" class="pill muted">未検出</span></div>
      <div style="grid-column: 1 / 3;"><span class="key">予告音氷（ハズレ）</span><span id="sig-yohaku-hazure" class="pill muted">未検出</span></div>
    `;
    setText("sig-bb-slant", ex.bb_slant_den? `1/${ex.bb_slant_den.toFixed(2)}` : "未検出");
    setText("sig-bb-rare",  ex.bb_rare_den ? `1/${ex.bb_rare_den.toFixed(1)}`  : "未検出");
    setText("sig-rt-hc",    ex.rt_hc_den   ? `1/${ex.rt_hc_den.toFixed(2)}`    : "未検出");
    setText("sig-rt-hg",    ex.rt_hg_den   ? `1/${ex.rt_hg_den.toFixed(2)}`    : "未検出");
    const rbMissCount = toNum(state.extra.rb_miss_count);
    setText("sig-rb-miss",  Number.isFinite(rbMissCount)? `${rbMissCount}回` : "未検出");
    setText("sig-yohaku-hazure", state.flags.yohakuHazure? "チェックON（設定1・2=0%）" : "未検出");
  } else if (state.currentMachineKey === "ALEX_BRIGHT") {
    signalsEl.innerHTML = `
      <div><span class="key">BB中リーチ目（ハズレ）</span><span id="sig-bb-reach-hazure" class="pill muted">未検出</span></div>
      <div><span class="key">RB特殊終了画面</span><span id="sig-rb-special-end" class="pill muted">未検出</span></div>
      <div><span class="key">BB中羽羽鳥C回数</span><span id="sig-bb-wing-hahan" class="pill muted">未検出</span></div>
      <div style="grid-column: 1 / 3;"><span class="key">BB中リーチ目（手動）</span><span id="sig-bb-reach-hazure-flag" class="pill muted">未検出</span></div>
    `;
    const bbReachDen = ex.bb_reach_hazure_den;
    setText("sig-bb-reach-hazure", bbReachDen? `1/${bbReachDen.toFixed(1)}` : "未検出");
    
    const rbEndCount = ex.rb_special_end_count;
    const rbEndText = Number.isFinite(rbEndCount) ? `${rbEndCount}回` : "未検出";
    setText("sig-rb-special-end", rbEndText);
    const bbWingHahanText = ex.bb_wing_hahan_count ? `${ex.bb_wing_hahan_count}回` : (ex.bb_wing_hahan_den ? `1/${ex.bb_wing_hahan_den.toFixed(1)}` : "未検出");
    setText("sig-bb-wing-hahan", bbWingHahanText);
    setText("sig-bb-reach-hazure-flag", state.flags.bb_reach_hazure_flag? "チェックON（設定1・2=0%）" : "未検出");
  }
}
function renderMetrics(firstRender=false){
  const wrap=$("metrics");
  // rb_miss_count は metrics に入れず extra で管理（回数のみのため）
  const keys = currentMachine.PRIMARY_METRICS.filter(k => k !== "rb_miss_count"); 
  
  if(firstRender){
    wrap.innerHTML="";
    // 総G
    let row=document.createElement("label"); row.style.display="flex"; row.style.alignItems="center"; row.style.gap="8px";
    let keySpan=document.createElement("span"); keySpan.className="key"; 
    keySpan.textContent=currentMachine.METRIC_LABELS.games; row.appendChild(keySpan);
    let input=document.createElement("input"); input.type="number"; input.step="1"; input.id=`inp-games`;
    input.value = state.metrics.games ?? "";
    input.oninput=(e)=>{
      if(!state.flags.edit) return;
      const v = e.target.value==="" ? undefined : toNum(e.target.value);
      state.metrics.games=v;
      renderBars();
      keys.forEach(k=>updatePerG(k)); 
    };
    input.onblur=()=>{ renderMetrics(false); };
    row.appendChild(input);
    let tail=document.createElement("span"); tail.className="perg"; tail.id=`perg-games`; tail.textContent="/G 0.0000"; row.appendChild(tail);
    wrap.appendChild(row);
    // 主要小役
    keys.forEach(k=>{
      row=document.createElement("label"); row.style.display="flex"; row.style.alignItems="center"; row.style.gap="8px";
      keySpan=document.createElement("span"); keySpan.className="key"; 
      keySpan.textContent=currentMachine.METRIC_LABELS[k] || k; row.appendChild(keySpan);
      input=document.createElement("input"); input.type="number"; input.step="1"; input.id=`inp-${k}`;
      
      const val = state.metrics[k] ?? undefined;
      input.value = val ?? "";
      
      input.oninput=(e)=>{
        if(!state.flags.edit) return;
        const v = e.target.value==="" ? undefined : toNum(e.target.value);
        state.metrics[k]=v;
        renderBars();
        updatePerG(k);
      };
      input.onblur=()=>{ renderMetrics(false); };
      row.appendChild(input);
      tail=document.createElement("span"); tail.className="perg"; tail.id=`perg-${k}`; row.appendChild(tail);
      wrap.appendChild(row);
    });
    
    // 特殊な回数のみの項目（新ハナビのRB中ハズレ）
    if (state.currentMachineKey === "SHIN_HANABI") {
      const rbMissKey = "rb_miss_count";
      row=document.createElement("label"); row.style.display="flex"; row.style.alignItems="center"; row.style.gap="8px";
      keySpan=document.createElement("span"); keySpan.className="key"; 
      keySpan.textContent=currentMachine.METRIC_LABELS[rbMissKey] || rbMissKey; row.appendChild(keySpan);
      input=document.createElement("input"); input.type="number"; input.step="1"; input.id=`inp-${rbMissKey}`;
      
      const val = state.extra[rbMissKey] ?? undefined;
      input.value = val ?? "";
      
      input.oninput=(e)=>{
        if(!state.flags.edit) return;
        const v = e.target.value==="" ? undefined : toNum(e.target.value);
        state.extra[rbMissKey]=v;
        renderBars();
        updateSignals(state.extra);
      };
      input.onblur=()=>{ renderMetrics(false); };
      row.appendChild(input);
      tail=document.createElement("span"); tail.className="perg"; tail.id=`perg-${rbMissKey}`; row.appendChild(tail);
      wrap.appendChild(row);
    }
  }
  
  // 編集モードON/OFFで状態を反映
  ["games"].concat(keys).forEach(k=>{
    const input=$(`inp-${k}`);
    if(input){
      const val = state.metrics[k] ?? undefined;
      if(document.activeElement!==input){ 
        // 抽出値がundefinedの場合、UIの値をリセットしない（手動入力の可能性を考慮）
        if(val !== undefined) input.value = val ?? ""; 
      }
      input.disabled = !state.flags.edit;
      updatePerG(k);
    }
  });
  if (state.currentMachineKey === "SHIN_HANABI") {
      const rbMissKey = "rb_miss_count";
      const input=$(`inp-${rbMissKey}`);
      if(input){
        const val = state.extra[rbMissKey] ?? undefined;
        if(document.activeElement!==input){ 
          if(val !== undefined) input.value = val ?? "";
        }
        input.disabled = !state.flags.edit;
      }
  }
  const ul = $("log"); ul.innerHTML = "";
  state.log.slice(-30).forEach(msg=>{ const li=document.createElement("li"); li.textContent=msg; ul.appendChild(li); });
}
function updatePerG(k){
  const span=$(`perg-${k}`);
  const g = toNum(state.metrics.games);
  const count = toNum(state.metrics[k]);
  
  if(k!=="games" && g && Number.isFinite(count)){
    const per=(count||0)/g;
    span.textContent = Number.isFinite(per) ? "/G "+per.toFixed(4) : "";
  }else if (k==="games") {
    span.textContent = "/G 0.0000"; 
  } else {
    span.textContent = "";
  }
}
function renderAllTable(){
  const tb = $("table-all").querySelector("tbody");
  tb.innerHTML = "";
  const rows = state.allItems;
  if(!rows.length){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td colspan="4" class="muted">抽出できた項目がありません。</td>`;
    tb.appendChild(tr);
    return;
  }
  rows.forEach(r=>{
    const tr = document.createElement("tr");
    const note = currentMachine.NOTES[r.name] || "";
    tr.innerHTML = `<td>${r.name}</td>
      <td>${Number.isFinite(r.count)? r.count : "—"}</td>
      <td>${Number.isFinite(r.denom)? "1/"+r.denom.toFixed(2) : "—"}</td>
      <td>${note||"—"}</td>`;
    tb.appendChild(tr);
  });
}
function loadMachine(machineKey) {
    state.currentMachineKey = machineKey;
    currentMachine = MACHINE_DATA[machineKey];
    if (!currentMachine) {
        setError(`機種データが見つかりません: ${machineKey}`);
        return;
    }
    // 機種名/タイトル更新
    $("machine-select").value = machineKey;
    document.querySelector('h1').textContent = `特リプTV｜設定推測ツール（${currentMachine.displayName}対応版：2025.10.12 Rev.8）`; // <-- Rev.8に更新
    
    // データをクリアして初期化
    state.metrics={games:undefined};
    currentMachine.PRIMARY_METRICS.forEach(k => state.metrics[k] = undefined);
    state.extra={};
    state.allItems=[];
    state.log=[];
    
    // チェックボックスのリセット・再描画
    state.flags={ peace:false, edit:state.flags.edit, yohakuHazure:false, bb_reach_hazure_flag:false }; // editモードは維持
    
    const optsEl = $("machine-specific-opts");
    optsEl.innerHTML = currentMachine.OPTS_HTML;
    // イベントリスナー再設定
    if (machineKey === "SHIN_HANABI") {
        const peaceEl = $("peace");
        const yohakuEl = $("yohaku-hazure");
        if (peaceEl) peaceEl.onchange = (e) => { state.flags.peace = e.target.checked; renderBars(); };
        if (yohakuEl) yohakuEl.onchange = (e) => { state.flags.yohakuHazure = e.target.checked; updateSignals(state.extra); renderBars(); };
    } else if (machineKey === "ALEX_BRIGHT") {
        const reachFlagEl = $("bb_reach_hazure_flag");
        if (reachFlagEl) reachFlagEl.onchange = (e) => { state.flags.bb_reach_hazure_flag = e.target.checked; updateSignals(state.extra); renderBars(); };
    }
    renderMetrics(true); 
    updateSignals(state.extra);
    renderAllTable();
    renderBars();
}
/* ---------- init ---------- */
function init(){
  // 初期機種のデータ挿入（アレックスブライトのデモデータを使用）
  const alexBrightSample = `アレックス ブライト
遊技履歴 全1件
2025/09 - 1件
基本情報
総プレイ数 1,200G
総ボーナス回数 4回
1/300.0
小役
羽合算回数 86回 1/14.0
羽A回数 43回 1/27.9
羽B回数 43回 1/27.9
羽鳥回数 36回 1/33.3
ブドウ回数 4回 1/300.0
チェリー合算回数 59回 1/20.3
チェリーA1回数 12回 1/100.0
チェリーA2回数 32回 1/40.0
チェリーB回数 17回 1/70.6
ボーナス
総ボーナス回数 4回 1/300.0
総BB回数 3回 1/400.0
赤7BB回数 1回 1/600.0
青7BB回数 2回 1/1,200.0
総RB回数 1回 1/1,200.0
最大連荘回数 1回
BB中詳細
BB中羽鳥A回数 14回 1/4.3
BB中羽鳥B回数 1回 1/60.0
BB中羽鳥C回数 0回 1/-
その他
RB特殊終了画面表示回数 0回
リーチ目スコア 1P
獲得スコア
リーチ目コレクション
新規 1/150`;
  $("text").value = alexBrightSample;
  
  loadMachine("ALEX_BRIGHT"); // 初期機種ロード
  
  // 機種選択ハンドラ
  $("machine-select").addEventListener("change",(e)=>{
      loadMachine(e.target.value);
  });
  $("btn-parse").addEventListener("click", ()=>{
    try{
      setError("");
      state.metrics = parseMetricsFromText($("text").value||"");
      if(!toNum(state.metrics.games)){
        setError("総Gが見つかりませんでした。");
      }
      
      const primaryKeys = currentMachine.PRIMARY_METRICS.filter(k => k !== "rb_miss_count");
      const gotCount = primaryKeys.filter(k => toNum(state.metrics[k]) != null).length;
      if(gotCount < 3 && primaryKeys.length >= 3) {
          setError(`主要小役（${primaryKeys.map(k => currentMachine.METRIC_LABELS[k]).join('/')}）の検出数が不足しています（${gotCount} / ${primaryKeys.length}）。`);
      }
      
      renderMetrics(false); renderBars();
    }catch(err){ setError("解析中にエラー: "+(err && err.message ? err.message : String(err))); }
  });
  $("edit-mode").addEventListener("change",(e)=>{ state.flags.edit = e.target.checked; renderMetrics(false); });
}
init();
</script>
</body>
</html>
