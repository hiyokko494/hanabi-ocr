<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>特リプTV｜新ハナビ 専用（見出し区間対応）</title>
<style>
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic","Meiryo",sans-serif;margin:24px;color:#111}
  h1{font-size:20px;margin:0 0 12px}
  .hint{background:#fff7ed;border:1px solid #fed7aa;color:#7c2d12;padding:8px 10px;border-radius:8px;font-size:13px}
  .error{background:#fef2f2;border:1px solid #fecaca;color:#991b1b;padding:8px 10px;border-radius:8px;font-size:13px;margin-top:8px;display:none}
  .row{display:flex;flex-wrap:wrap;align-items:center;gap:8px;margin-top:12px}
  .btn{font-size:13px;padding:6px 10px;border-radius:6px;border:0;cursor:pointer}
  .btn.primary{background:#111;color:#fff}
  .card{background:#f9fafb;border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin-top:12px}
  .card h3{margin:0 0 8px;font-size:14px}
  textarea{width:100%;height:160px;border:1px solid:#e5e7eb;border-radius:8px;padding:8px;font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:8px}
  @media(min-width:640px){.grid{grid-template-columns:1fr 1fr}}
  label span.key{width:120px;color:#374151;display:inline-block}
  input[type="number"]{border:1px solid #e5e7eb;border-radius:6px;padding:6px 8px;width:100%}
  .perg{font-size:11px;color:#6b7280;width:80px;text-align:right}
  .bar-wrap{width:100%;height:16px;background:#e5e7eb;border-radius:999px;overflow:hidden}
  .bar{height:16px;transition:width .3s ease}
  .rowline{display:flex;align-items:center;justify-content:space-between;font-size:12px;margin-bottom:4px}
  .footer{margin-top:16px;font-size:12px;color:#6b7280}
  code{background:#f3f4f6;padding:0 4px;border-radius:4px}
</style>
</head>
<body>
<h1>特リプTV｜新ハナビ 専用（見出し区間対応）</h1>
<div class="hint">
  ユニメモのテキストをそのまま貼って「テキストから解析」。<br>
  ※ 総Gは<b>「6,056G」形式の行</b>のみ採用（最大値）。小役は<b>見出し→次の見出しまでの区間</b>内で「◯回＋直後の 1/◯◯」ペアを取得します。
</div>

<div id="err" class="error"></div>

<div class="card">
  <div style="display:flex;align-items:center;justify-content:space-between;">
    <h3>テキスト（手動貼り付け）</h3>
    <button id="btn-parse" class="btn primary" type="button">テキストから解析</button>
  </div>
  <textarea id="text" placeholder="（ここにユニメモのテキストを丸ごと貼り付け）"></textarea>
</div>

<div class="card">
  <h3>抽出メトリクス（編集可）</h3>
  <div class="grid" id="metrics"></div>
</div>

<div class="card">
  <h3>推測比較（最大=赤、最小=水色）</h3>
  <div id="bars">必要な数値が揃うと比較グラフが表示されます。</div>
</div>

<div class="footer">
  元のUI/計算は維持。抽出のみ「見出し区間」方式へ。:contentReference[oaicite:1]{index=1}
</div>

<script>
/* === 期待値 (/G) === */
const EXPECT = {
  bell:  [1/7.7,  1/7.6,  1/7.5,  1/7.3],
  cherry:[1/16.4, 1/15.3, 1/16.1, 1/15.6],
  ice:   [1/51.2, 1/51.8, 1/48.2, 1/49.3],
};

const state = { metrics: { games: undefined, bell: undefined, cherry: undefined, ice: undefined } };

/* ---- 正規化 ---- */
function sanitize(s){
  return (s||"")
    .replace(/[０-９]/g,d=>String.fromCharCode(d.charCodeAt(0)-0xFEE0))
    .replace(/[，]/g,",").replace(/[．]/g,".").replace(/[　]/g," ")
    .replace(/[：:]\s*/g,":")
    .replace(/\s+\/\s+/g,"/")
    .replace(/\s{2,}/g," ")
    .trim();
}

/* ---- パターン ---- */
const RE_LINE_G_ONLY   = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*G\s*$/i;     // 行全体が「◯◯G」
const RE_LINE_KAI_ONLY = /^\s*([0-9]{1,3}(?:,[0-9]{3})*)\s*回\s*$/;      // 行全体が「◯◯回」
const RE_LINE_FRAC     = /^\s*1\s*\/\s*([0-9]+(?:\.[0-9]+)?)\s*$/;       // 行全体が「1/◯◯」
const RE_HEAD_GAMES    = /総[ププ]レイ|総プレイ数|総ゲーム|総回転|総G数|ゲーム数|回転数/i;
const HEAD_ORDER = [
  /風鈴合算/i, /風鈴A/i, /風鈴B/i,
  /氷合算/i,   /氷A/i,   /氷B/i,
  /チェリー合算/i, /チェリーA1/i, /チェリーA2/i, /チェリーB/i,
  /RT|BB中|RB中|最大|お気に入り|大花火|ドンちゃん|100G以内/i // 次の大きなセクションの境界
];

/* ---- 区間抽出ユーティリティ ---- */
// 見出しリストのうち、先頭にマッチした行indexを返す
function findHead(lines, re){ return lines.findIndex(l=>re.test(l)); }
// lines[start+1 .. end-1] で「行=◯回」「次行=1/◯◯」の最初のペアを返す
function firstPairIn(lines, start, end){
  for(let i=start+1; i<end && i<lines.length-1; i++){
    const mCnt = RE_LINE_KAI_ONLY.exec(lines[i]);
    if(!mCnt) continue;
    const mFrac= RE_LINE_FRAC.exec(lines[i+1]);
    if(!mFrac) continue;
    return { count: Number(mCnt[1].replace(/,/g,"")), denom: parseFloat(mFrac[1]) };
  }
  return null;
}
// start 以降で、HEAD_ORDER のどれかに当たる「次の見出し」を探す（start自身は含めない）
function nextHeadIndex(lines, start){
  for(let i=start+1;i<lines.length;i++){
    if(HEAD_ORDER.some(re=>re.test(lines[i]))) return i;
  }
  return lines.length;
}

/* ---- 抽出本体（新ハナビ専用） ---- */
function parseMetricsFromText(textRaw){
  const t = sanitize(textRaw);
  const lines = t.split(/\r?\n/);

  const out = { games: undefined, bell: undefined, cherry: undefined, ice: undefined };

  // 総G：行全体が「◯◯G」のみ収集し最大値
  const gCandidates = lines.map(ln=>{
    const m=RE_LINE_G_ONLY.exec(ln); return m?Number(m[1].replace(/,/g,"")):null;
  }).filter(v=>v!=null);
  if(gCandidates.length) out.games = Math.max(...gCandidates);
  else {
    // 見出し行の後に現れる G-only をフォールバックで採用
    const idx = findHead(lines, RE_HEAD_GAMES);
    if(idx>=0){
      for(let i=idx+1;i<lines.length;i++){
        const m=RE_LINE_G_ONLY.exec(lines[i]); if(m){ out.games=Number(m[1].replace(/,/g,"")); break; }
      }
    }
  }

  // 風鈴合算の区間
  const h_bell = findHead(lines, /風鈴合算/i);
  if(h_bell>=0){
    const end = nextHeadIndex(lines, h_bell);
    const p = firstPairIn(lines, h_bell, end);
    if(p) out.bell = p.count;
  }
  // 氷合算の区間
  const h_ice = findHead(lines, /氷合算/i);
  if(h_ice>=0){
    const end = nextHeadIndex(lines, h_ice);
    const p = firstPairIn(lines, h_ice, end);
    if(p) out.ice = p.count;
  }
  // チェリー合算の区間
  const h_ch = findHead(lines, /チェリー合算/i);
  if(h_ch>=0){
    const end = nextHeadIndex(lines, h_ch);
    const p = firstPairIn(lines, h_ch, end);
    if(p) out.cherry = p.count;
  }

  return out;
}

/* ---- 推測（元の算出：二乗誤差→正規化） ---- */
function estimateAllSettings(metrics){
  const g = metrics.games || 0;
  if(!g) return [];
  const perG = {};
  ["bell","cherry","ice"].forEach(k=>{ if(metrics[k]!=null) perG[k]=metrics[k]/g; });

  const rows=[1,2,5,6].map((s,i)=>{
    let err=0, used=0;
    if(perG.bell  !=null){ err += Math.pow(perG.bell  - EXPECT.bell[i] ,2); used++; }
    if(perG.cherry!=null){ err += Math.pow(perG.cherry- EXPECT.cherry[i],2); used++; }
    if(perG.ice   !=null){ err += Math.pow(perG.ice   - EXPECT.ice[i]   ,2); used++; }
    const score = used ? 1/(1+err) : 0;
    return { setting:s, score, percent:0 };
  });
  const sum = rows.reduce((a,b)=>a+b.score,0) || 1;
  rows.forEach(r=>r.percent = r.score/sum*100);
  return rows;
}

/* ---- UI ---- */
function barColor(p,max,min){
  if(p===max) return"rgba(239,68,68,0.85)";
  if(p===min) return"rgba(147,197,253,0.85)";
  const t=(p-min)/Math.max(1,max-min);
  const r=Math.round(147+(59-147)*t), g=Math.round(197+(130-197)*t), b=Math.round(253+(246-253)*t);
  return`rgba(${r},${g},${b},0.9)`;
}
function renderMetrics(){
  const wrap=document.getElementById("metrics"); wrap.innerHTML="";
  const keys=["games","bell","cherry","ice"];
  const label={games:"総G", bell:"風鈴合算", cherry:"チェリー合算", ice:"氷合算"};
  keys.forEach(k=>{
    const row=document.createElement("label"); row.style.display="flex"; row.style.alignItems="center"; row.style.gap="8px";
    const keySpan=document.createElement("span"); keySpan.className="key"; keySpan.textContent=label[k]; row.appendChild(keySpan);
    const input=document.createElement("input"); input.type="number"; input.inputMode="numeric";
    input.value = state.metrics[k] ?? "";
    input.oninput = (e)=>{ state.metrics[k] = e.target.value==="" ? undefined : Number(e.target.value); renderBars(); renderMetrics(); };
    row.appendChild(input);
    const tail=document.createElement("span"); tail.className="perg";
    if(k!=="games" && state.metrics.games){ tail.textContent="/G "+(((state.metrics[k]||0)/(state.metrics.games||1)).toFixed(4)); }
    row.appendChild(tail);
    wrap.appendChild(row);
  });
}
function renderBars(){
  const mount=document.getElementById("bars");
  const rows=estimateAllSettings(state.metrics);
  if(!rows.length){ mount.textContent="必要な数値が揃うと比較グラフが表示されます。"; return; }
  const perc=rows.map(r=>r.percent), max=Math.max(...perc), min=Math.min(...perc);
  mount.innerHTML="";
  rows.forEach(r=>{
    const head=document.createElement("div"); head.className="rowline";
    head.innerHTML=`<span>新ハナビ｜設定${r.setting}</span><span>${r.percent.toFixed(2)}%</span>`;
    const barWrap=document.createElement("div"); barWrap.className="bar-wrap";
    const bar=document.createElement("div"); bar.className="bar";
    bar.style.width=Math.max(0,Math.min(100,r.percent))+"%";
    bar.style.background=barColor(r.percent,max,min);
    barWrap.appendChild(bar);
    mount.appendChild(head); mount.appendChild(barWrap);
  });
}
function setError(msg){ const e=document.getElementById("err"); e.style.display=msg?"block":"none"; e.textContent=msg||""; }

/* ---- init ---- */
function init(){
  renderMetrics(); renderBars();
  document.getElementById("btn-parse").addEventListener("click", ()=>{
    setError(""); const text=document.getElementById("text").value||"";
    state.metrics = parseMetricsFromText(text);

    if(!state.metrics.games){ setError("総G（例: 6,056G）が見つかりませんでした。"); }
    else{
      const got = ["bell","cherry","ice"].filter(k=>state.metrics[k]!=null);
      if(got.length===0) setError("『風鈴合算／チェリー合算／氷合算』の見出しの後にある回数＋1/◯◯が見つかりませんでした。");
    }
    renderMetrics(); renderBars();
  });

  // 自己テスト（いただいた構成に近い順序）
  try{
    const sample = [
      "基本情報","総プレイ数","小役","風鈴合算","風鈴A","風鈴B",
      "氷合算","氷A","氷B","チェリー合算","チェリーA1","チェリーA2","チェリーB",
      "6,056G","813回","1/7.4","103回","1/58.8","381回","1/15.9"
    ].join("\n");
    const m = parseMetricsFromText(sample);
    console.assert(m.games===6056 && m.bell===813 && m.cherry===381 && m.ice===103, "zone parsing ok");
  }catch(_){}
}
init();
</script>
</body>
</html>
